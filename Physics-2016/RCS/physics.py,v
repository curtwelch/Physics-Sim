head	1.37;
access;
symbols;
locks; strict;
comment	@# @;


1.37
date	2021.02.05.19.14.40;	author curtwelch;	state Exp;
branches;
next	1.36;

1.36
date	2020.04.10.00.05.52;	author curtwelch;	state Exp;
branches;
next	1.35;

1.35
date	2016.10.12.16.44.52;	author curt;	state Exp;
branches;
next	1.34;

1.34
date	2016.10.11.18.21.41;	author curt;	state Exp;
branches;
next	1.33;

1.33
date	2016.10.10.12.14.41;	author curt;	state Exp;
branches;
next	1.32;

1.32
date	2016.10.09.18.43.08;	author curt;	state Exp;
branches;
next	1.31;

1.31
date	2016.10.08.19.52.43;	author curt;	state Exp;
branches;
next	1.30;

1.30
date	2016.10.07.21.36.24;	author curt;	state Exp;
branches;
next	1.29;

1.29
date	2016.10.07.18.45.44;	author curt;	state Exp;
branches;
next	1.28;

1.28
date	2016.10.05.22.31.11;	author curt;	state Exp;
branches;
next	1.27;

1.27
date	2016.10.04.13.46.31;	author curt;	state Exp;
branches;
next	1.26;

1.26
date	2016.10.03.14.37.28;	author curt;	state Exp;
branches;
next	1.25;

1.25
date	2016.10.01.12.35.00;	author curt;	state Exp;
branches;
next	1.24;

1.24
date	2016.09.30.13.55.15;	author curt;	state Exp;
branches;
next	1.23;

1.23
date	2016.09.29.20.13.58;	author curt;	state Exp;
branches;
next	1.22;

1.22
date	2016.09.28.14.52.33;	author curt;	state Exp;
branches;
next	1.21;

1.21
date	2016.09.27.14.02.57;	author curt;	state Exp;
branches;
next	1.20;

1.20
date	2016.09.26.15.06.05;	author curt;	state Exp;
branches;
next	1.19;

1.19
date	2016.09.25.12.25.05;	author curt;	state Exp;
branches;
next	1.18;

1.18
date	2016.09.24.12.43.50;	author curt;	state Exp;
branches;
next	1.17;

1.17
date	2016.09.19.16.46.46;	author curt;	state Exp;
branches;
next	1.16;

1.16
date	2016.09.17.13.39.01;	author curt;	state Exp;
branches;
next	1.15;

1.15
date	2016.09.07.18.11.11;	author curt;	state Exp;
branches;
next	1.14;

1.14
date	2016.09.05.17.43.18;	author curt;	state Exp;
branches;
next	1.13;

1.13
date	2016.09.02.14.59.54;	author curt;	state Exp;
branches;
next	1.12;

1.12
date	2016.08.30.17.07.59;	author curt;	state Exp;
branches;
next	1.11;

1.11
date	2016.08.28.14.10.43;	author curt;	state Exp;
branches;
next	1.10;

1.10
date	2016.08.27.13.12.05;	author curt;	state Exp;
branches;
next	1.9;

1.9
date	2016.08.25.15.59.54;	author curt;	state Exp;
branches;
next	1.8;

1.8
date	2016.08.24.14.43.34;	author curt;	state Exp;
branches;
next	1.7;

1.7
date	2016.08.23.22.24.36;	author curt;	state Exp;
branches;
next	1.6;

1.6
date	2016.08.23.16.23.46;	author curt;	state Exp;
branches;
next	1.5;

1.5
date	2016.08.22.17.41.23;	author curt;	state Exp;
branches;
next	1.4;

1.4
date	2016.08.16.21.06.14;	author curt;	state Exp;
branches;
next	1.3;

1.3
date	2016.08.16.18.31.30;	author curt;	state Exp;
branches;
next	1.2;

1.2
date	2016.05.19.20.50.09;	author curt;	state Exp;
branches;
next	1.1;

1.1
date	2016.05.18.18.15.59;	author curt;	state Exp;
branches;
next	;


desc
@physics.py -- atomic simulation code
@


1.37
log
@check in old chanages.
@
text
@#/usr/bin/python

"""
    physics.py - Atomic particle simulation experments

    2016-05-18 Started this file.  Took it from xnet.py from my AI work.

"""

import random
import time
import sys
import math
import heapq
import numpy as np
import matplotlib.pyplot as plt
from operator import attrgetter

import os
import pygame

black = 0, 0, 0
white = 255, 255, 255
red = 255, 0, 0

Angstrom = 1.0e-10 # One Angstrom 10e-10 meters

RLimit = 0.1 * Angstrom			# Radius limit hack
RLimit = 0.0001 * Angstrom		# Radius limit hack
RLimit = 0.0000001 * Angstrom		# Radius limit hack

InsideRLimitCount = 0
eBounceCount = 0
pBounceCount = 0

FakeConstants = False

doMagnetic = False
doMagneticInverse = False

dt = 2e-17
dt = 2e-18
dt = 2e-19

dtMin = 1e-20
dtMin = 1e-30

dtMax = 1e-10
dtMax = 1e-1

dt = dtMin
dtAdjust = True

energyFix = False # fix based on total PE+KE at start -- doesn't work when magnatism added
energyFix2 = False

screen_size = screen_width, screen_height = 1000, 800
screen_size = screen_width, screen_height = 600, 400
screen_depth = 1000 # z dimension

pixelsPerAngstrom = 4000.0
pixelsPerAngstrom = 0.00001
pixelsPerAngstrom = 100000000.0
pixelsPerAngstrom = 10000.0
pixelsPerAngstrom = 5.0
pixelsPerAngstrom = 200.0

def magCircleTest():

    # Copy forceCircleTest to crete magfCircleTest()
    # What is the mag field at different points?
    # Using Biot-Savant law the mag field is
    # dB = u0 I Dl x rHat / 4Pi R^2
    # I must intergrate this all around the circule
    # for different points.
    # I'll just sum it up over the small steps
    # for different points.

    # Circle of radius 1. Using fake force as 1/d^2.
    # center at origin.
    # Field always points in same z direction.
    # So I just sum all the parts.

    y = 0.0
    z = 0.0
    for i in range(11):
	x = i * 0.1
	print "For x,y", x, y,
	bTotal = 0.0
	steps = 4000
	dl =  2.0 * math.pi / steps
	lastpx = 0.0  # First point
	lastpy = 1.0
	for i in range(1, steps+1):
	    anglei = 2.0*math.pi * i / steps
	    px = math.sin(anglei)
	    py = math.cos(anglei)
	    dl = math.sqrt((lastpx-px)**2.0 + (lastpy-py)**2.0)
	    dx = px-x
	    dy = py-y
	    r2 = dx**2 + dy**2
	    r = math.sqrt(r2)
	    # For 1 amp current
	    b = 1e-7 * dl / r # fake for expermenting
	    b = 1e-7 * dl / 1.0 # Fake again
	    b = 1e-7 * dl / r2 # Real
	    bTotal += b
	    lastpx = px
	    lastpy = py
	print "total mag field is", bTotal
    sys.exit(1)

    # Conclusion ...
    # Mag field is weakest in middle, stronger near edges 
    # But is somewhat the same till it gets real near the edge?
    # Switching from 1/r^2 to 1/r doesn't make it the same!
    # But switching to 1/1 does!  But then we are just calculating 2 pi r I!  So of course!
    # For x,y 0.0 0.0 total mag field is 6.28318466122e-07
    # For x,y 0.1 0.0 total mag field is 6.34665117294e-07
    # For x,y 0.2 0.0 total mag field is 6.5449840221e-07
    # For x,y 0.3 0.0 total mag field is 6.90459852881e-07
    # For x,y 0.4 0.0 total mag field is 7.47998173954e-07
    # For x,y 0.5 0.0 total mag field is 8.37757954829e-07
    # For x,y 0.6 0.0 total mag field is 9.81747603315e-07
    # For x,y 0.7 0.0 total mag field is 1.2319969924e-06
    # For x,y 0.8 0.0 total mag field is 1.74532907256e-06
    # For x,y 0.9 0.0 total mag field is 3.30693929538e-06
    # For x,y 1.0 0.0 total mag field is 4.18946069487e+22  infinity? 0/0?


def forceCircleTest():
    # What is the total force inside a circle of particles?
    # Is it the same at all places inside the circle or is it
    # different based on loacdtion.  Just do some quick math
    # test to find out.  In 2 dimensions.

    # Circle of radius 1. Using fake force as 1/d^2.
    # center at origin.

    y = 0.0
    z = 0.0
    for i in range(9):
	x = i * 0.1
	print "For x,y", x, y,
	fx = 0.0
	fy = 0.0
	fz = 0.0
	steps = 400 
	for i in range(steps):
	    for j in range(steps):
		anglei = 2.0*math.pi * i / steps
		anglej = 2.0*math.pi * j / steps
		px = math.sin(anglei)
		py = math.cos(anglei)
		pz = math.cos(anglej)
		dx = px-x
		dy = py-y
		dz = pz-z
		d2 = dx**2 + dy**2 + dz**2
		r = math.sqrt(d2)
		force = 1.0/r
		force = 1.0/d2
		# Had to add /px below to adjust for the ds factor
		# that our step pattern was wrong
		fx += force * dx / r * px
		fy += force * dy / r * px
		fz += force * dz / r * px
	print "total force is", fx, fy, fz
    sys.exit(1)

    # Conclusion ...
    # Force at point inside cirucle only sums to a constant if the
    # force equation is 1/x  not 1/x^2.
    # Force sums to constant when we sum over entire spher for 1/x^22 force.
    # This makes sense because the size of the circle is 2pi r, or 4pi r^2 for surface
    # The use of 1/x^2 in physics is consistent with conservation in 3D space.


def fastTest():
    p1 = Proton(0.0, 00.0, 0.0)
    p1 = Electron(0.0, 00.0, 0.0)
    for i in range(60):
	x = (i-30) * Angstrom / 10 
	e1 = Electron(x, 0.0, 0.0)
	print "i", i, "x", x, x/Angstrom, "A",
	print p1.potentialEnergy(e1)

    sys.exit(1)

def neutronGravityTest():
    # Some experment on the idea that a netron is
    # is really a e p pair in orbit.  What would
    # be the attraction between two such systems?
    # Does it match gravity in relative force?
    # The answer was the attraction is not even
    # 1/x^2 in force!  Opps.  That theory got blown
    # out of the water!  The overlaping fields does
    # create a 1/x^2 field!
    # UGH -- 5-11-2018 thoughts: but do two systems in
    # orbit actually end up moving closer together or
    # further apart due to distroted orbits and orbital
    # intereactions -- this test did not answer that question
    # and if the effect appxoimates 1/x^2 then it could be
    # mistaken as 1/^x^2.  More testing required

    closeSpace = 0.0001 * Angstrom
    p1 = Proton(0.0, 0.0, 0.0)
    e1 = Electron(0.0 + closeSpace, 0.0, 0.0)

    p2 = Proton(100.0, 0.0, 0.0)
    e2 = Electron(100.0 + closeSpace, 0.0, 0.0)

    gravityForce = 0.0
    gravityForce += p2.gravityForce(p1)
    gravityForce += p2.gravityForce(e1)
    gravityForce += e2.gravityForce(p1)
    gravityForce += e2.gravityForce(e1)

    print "Gravity force between two is:", gravityForce

    p2.zeroForce()
    p2.addForce(p1)
    print "em force p2 to p1", p2.fx
    emForce = p2.fx

    p2.zeroForce()
    p2.addForce(e1)
    print "em force p2 to e1", p2.fx
    emForce += p2.fx

    print "em force p2 to e1 and p1", emForce

    sys.exit(1)

def magneticTest():
    c = 299792458.0 # Speed of light m/s

    world = []

    p1 = Electron(0.0, 0.0, 0.0)
    p1 = Proton(0.0, 0.0, 0.0)
    # p1.vx = c/2.0
    # p1.vy = c/2.0
    # p1.vy = c/2.0
    # p1.vy = 2.0e8
    # p1.vz = 12.0e8
    world.append(p1)

    p2 = Electron(1.0*Angstrom, 0.0, 0.0)
    p2 = Electron(1.0*Angstrom, 1.0*Angstrom, 0.0)
    p2.vy = c/2.0
    # p2.vy = -c/4.0
    # p2.vy = 1.0e8
    # p2.vz = 6.0e8
    world.append(p2)

    p3 = Electron(1.0*Angstrom, 0.0, 0.0)
    p3 = Electron(1.0*Angstrom, 1.0*Angstrom, 0.0)
    p3.vx = -c/2.0
    p3.vy = -c/2.0
    # world.append(p3)

    maxV = c / math.sqrt(3.0)
    # print "max v is", maxV, "max mag is", math.sqrt(3.0 * maxV**2.0), "c is", c
    # zz

    if False:
	speed = c/2.0
	speed = maxV * random.random() 
	speed = c
	p1.vx = (random.random() * 2.0 - 1.0)
	p1.vy = (random.random() * 2.0 - 1.0)
	p1.vz = (random.random() * 2.0 - 1.0)
	p1.vx,p1.vy,p1.vz = p1.product(speed/magnatude(p1.V()), p1.V())

	speed = c/2.0
	speed = maxV * random.random() 
	speed = c
	p2.vx = (random.random() * 2.0 - 1.0)
	p2.vy = (random.random() * 2.0 - 1.0)
	p2.vz = (random.random() * 2.0 - 1.0)
	p2.vx,p2.vy,p2.vz = p2.product(speed/magnatude(p2.V()), p2.V())

    if False:
	# Make the magnatude of the difference equal to c
	rV = p1.subtract(p1.V(), p2.V())
	s = magnatude(rV)
	p1.vx,p1.vy,p1.vz = p1.product(c/s, p1.V())
	p2.vx,p2.vy,p2.vz = p2.product(c/s, p2.V())


    if False:
	p1.vx = 1.0
	p1.vy = 2.0
	p1.vz = 3.4
	p2.vx = 100.0
	p2.vy = 200.0
	p2.vz = 300.4

    # zz


    if False:
    	# Time step test -- move particles forward in time
	# Based on velocity, see what dr and ds is!
	p0 = world[0]
	rp0 = world[0].R()
	rp1 = world[1].R()
	rBefore = p0.subtract(rp1, rp0)
	esBefore = world[0].esForce(world[1])

	dt = 1e-20

	magneticTest2(world, dt=dt)

	for it in range(3):
	    for i in range(len(world)):
		p1 = world[i]
		p1.calculateEndVelocity(dt)
		p1.calculateEndPosition(dt)

	    for p1 in world:
		p1.zeroEndForce()
		for p2 in world:
		    p1.addEndForce(p2)

	for p1 in world:
	    p1.move()

	print
	print "Move Done!"
	print

	rp0 = world[0].R()
	rp1 = world[1].R()
	rAfter = p0.subtract(rp1, rp0)
	rDiff = p0.subtract(rAfter, rBefore)
	esAfter = world[0].esForce(world[1])
	esDiff = p0.subtract(esAfter, esBefore)

	print " dt is   ", dt
	print " r before", rBefore
	print " r after", rAfter
	print " dr =  after-before = ", rDiff
	print " dr diff magnatude", magnatude(rDiff)
	print " es before  ", esBefore
	print " es after   ", esAfter
	print " es diff    ", esDiff
	print " es diff magnatude", magnatude(esDiff)
	print


	magneticTest2(world, dt=dt)
	sys.exit(1)
	    

    magneticTest2(world)
    sys.exit(1)

    # zz

    print "ZERO Monumtum!"
    print
    zeroMomentum(world)
    magneticTest2(world)

    sys.exit(1)
    if False:
    	p1.vx = - p1.vx

    # Change velocities in different ways and print results again...

    if False:
	# Change frame of reference
	print "Change inertial Frame of reference randomly"

	# Because my test particles are on the same x axis, this
	# vx component is totally ignored in the equations so
	# I can assign random values without effecting the total force!
	# FALSE -- not true.  Changing dx changes fy and fz but not
	# fx.  So it is important, unless the vy and vz are zero.
	dx = maxV * (random.random() * 2.0 - 1.0)
	p1.vx += dx
	# dx = maxV * (random.random() * 2.0 - 1.0)
	p2.vx += dx

	dy = maxV * (random.random() * 2.0 - 1.0)

	p1.vy += dy
	p2.vy += dy

	dz = maxV * (random.random() * 2.0 - 1.0)

	p1.vz += dz
	p2.vz += dz

    if False:
	print "Change X velocities randomly"
    	# turns out, that doing this, has no
	# effect on the X force when the particles
	# are on the x axis!
	dx = maxV * (random.random() * 2.0 - 1.0)
	p1.vx += dx
	dx = maxV * (random.random() * 2.0 - 1.0)
	p2.vx += dx

    if False:
	print "Change Y velocities randomly"
    	# turns out, that doing this, has no
	# effect on the Z force when the particles
	# are on the x axis!
	dy = maxV * (random.random() * 2.0 - 1.0)
	p1.vy += dy
	dy = maxV * (random.random() * 2.0 - 1.0)
	p2.vy += dy

    if False:
	print "Change Z velocities randomly"
    	# turns out, that doing this, has no
	# effect on the Y force when the particles
	# are on the x axis!
	dz = maxV * (random.random() * 2.0 - 1.0)
	p1.vz += dz
	dz = maxV * (random.random() * 2.0 - 1.0)
	p2.vz += dz

    if False:
    	print "Randomly Rotate relative vx,vy vector!"
	# Coded this by mistake.  Meant to code vy,vz rotation which
	# I did below.  When we rotate vx,vy  vextor as I'm doinging
	# here, all forces change and the total magnature of the force
	# changes as well!
	rV = p1.subtract(p1.V(), p2.V())
	oldvx = rV[0]
	oldvy = rV[1]
	oldr = math.sqrt(rV[0]**2.0 + rV[1]**2.0)		# x^2 + y^2
	print "starting relative velocity is:", rV

	# New random x,y direction:
	dx = maxV * (random.random() * 2.0 - 1.0)
	dy = maxV * (random.random() * 2.0 - 1.0)

	# Now adjust length to match old:
	newr = math.sqrt(dx**2.0 + dy**2)
	dx = dx * oldr / newr
	dy = dy * oldr / newr

	print "old r2 was", oldr,
	print "new r2 is", math.sqrt(dx**2.0 + dy**2.0)

	# Now fudge one of the vx vy to change relative
	# vx,vy into dx,dy

	p1.vx -= oldvx - dx
	p1.vy -= oldvy - dy

	# Checck if this worked, is the new relatie V the same magnatude?
	rV = p1.subtract(p1.V(), p2.V())
	oldr = math.sqrt(rV[0]**2.0 + rV[1]**2.0)		# x^2 + y^2
	print "after rotation, magnature of vx,vy is", oldr
	print "ending   relative velocity is:", rV
	print


    if False:
    	print "Randomly Rotate relative vy,vz vector!"
	rV = p1.subtract(p1.V(), p2.V())
	oldvy = rV[1]
	oldvz = rV[2]
	oldr = math.sqrt(rV[1]**2.0 + rV[2]**2.0)		# y^2 + z^2
	print "starting relative velocity is:", rV

	# New random y,z direction:
	dy = maxV * (random.random() * 2.0 - 1.0)
	dz = maxV * (random.random() * 2.0 - 1.0)

	# Now adjust length to match old:
	newr = math.sqrt(dy**2.0 + dz**2)
	oldr2 = oldr * 2.0 # double magnatude to see what hapens
	oldr2 = oldr
	dy = dy * oldr2 / newr
	dz = dz * oldr2 / newr

	print "old r2 was", oldr,
	print "new r2 is", math.sqrt(dy**2.0 + dz**2.0)

	# Now fudge one of the vy vz to change relative
	# vy,vz into dy,dz

	p1.vy -= oldvy - dy
	p1.vz -= oldvz - dz

	# Checck if this worked, is the new relatie V the same magnatude?
	rV = p1.subtract(p1.V(), p2.V())
	oldr = math.sqrt(rV[1]**2.0 + rV[2]**2.0)		# y^2 + z^2
	print "after rotation, magnature of vy,vz is", oldr
	print "ending   relative velocity is:", rV
	print

    magneticTest2(world)

    sys.exit(1)

def magnatude(v):
    return math.sqrt(v[0]**2.0 + v[1]**2.0 + v[2]**2.0)

def magneticTest2(world, dt=None):
    doMagnetic = True
    doMagneticInverse = True

    for p1 in world:
	p1.zeroForce()
	for p2 in world:
	    p1.addForce(p2)  # ES Only

    c = 299792458.0 # Speed of light m/s

    for i in range(len(world)):
	p1 = world[i]
	print "%s%d X,Y %.1f, %.1f" % (p1.symbol, i, p1.x/Angstrom, p1.y/Angstrom)


    for i in range(len(world)):
	p1 = world[i]
	print "V of %s%i" % (p1.symbol, i), p1.V(), "%5.3fc %s" % (magnatude(p1.V())/c, p1.symbol)


    # p1p22 = p1.magneticForce3(p2)
    # p2p12 = p2.magneticForce3(p1)

    for i in range(len(world)):
	p1 = world[i]
	print "ES  Total Force on %s%d" % (p1.symbol, i), p1.F()

    totalMagForce = (0.0, 0.0, 0.0)

    for i in range(len(world)):
	p1 = world[i]
	for j in range(len(world)):
	    if i == j:
		continue
	    p2 = world[j]
	    f = p1.magneticForceTotal(p2, dt=dt)
	    print "%s%d.magneticForceTotal(%s%d)" % (p1.symbol, i, p2.symbol, j),
	    print f,
	    print magnatude(f)

	    totalMagForce = vectorSum(totalMagForce, f)

    print
    print "Total Mag force:", totalMagForce
    print

    # zz

def crtClear():
    sys.stdout.write("\033[2J")

def crtClearAndHome(row=0, col=0):
    crtClear()
    crtGOTO(row, col)

def crtGOTO(row, col):
    sys.stdout.write("\033[%d;%dH" % (row, col))

def crtMode(m=None):
    if m is None:
    	m = 0	# normal mode
    elif m == "normal":
    	m = 0
    elif m == "bold":
    	m = 1
    elif m == "underline":
    	m = 2
    elif m == "blinking":
    	m = 5
    elif m == "reverse video":
    	m = 7

    if m not in [0, 1, 2, 5, 7]:
    	raise Exception("Invlaid mode")
    
    sys.stdout.write("\033[%dm" % (m))


class Particle:
    # The basic particle code for protons and electons
    def __init__(self, x=0.0, y=0.0, z=0.0):
	# Units all standard SI meters, seconds, Newtons, Kg, Coulombs
    	self.x = x
	self.y = y
	self.z = z
	self.vx = 0.0
	self.vy = 0.0
	self.vz = 0.0
	self.fx = 0.0
	self.fy = 0.0
	self.fz = 0.0
	self.c = 299792458.0 # Speed of light m/s -- defined exact constant
	self.ke = 8.9875517873681764e9  # Coulomb's constant (1/4 pi e) written as K(sub)e
	self.ke = self.c * self.c * 1.0e-7 # exactly the same as above

	if FakeConstants:
	    self.ke = 1.0 	 # Coulomb's constant (1/4 pi e) written as K(sub)e
	# self.charge = -1.0

	self.avgKE = 0.0	# Running average of KE
	self.avgPE = 0.0	# Running average of PE

    def R(self):
    	return (self.x, self.y, self.z)

    def V(self):
    	return (self.vx, self.vy, self.vz)

    def F(self):
    	return (self.fx, self.fy, self.fz)

    def zeroForce(self): # and end force as well
    	self.fx = 0.0
	self.fy = 0.0
	self.fz = 0.0
	self.zeroEndForce()

    def zeroEndForce(self):
    	self.endFx = 0.0
    	self.endFy = 0.0
    	self.endFz = 0.0

    def addForce(self, p): # and set end force as well
    	if p is self:
	    return

	dx = (self.x - p.x)
	dy = (self.y - p.y)
	dz = (self.z - p.z)

	r2,l2 = self.distance2(p)

	if r2 == 0.0:
	    return # Bogus but prevents DBZ

	force = self.ke * (self.charge * p.charge) / l2

	r = math.sqrt(r2)

	self.fx += force * dx / r
	self.fy += force * dy / r
	self.fz += force * dz / r

	if doMagnetic:
	    f = self.magneticForceTotal(p)
	    self.fx += f[0]
	    self.fy += f[1]
	    self.fz += f[2]

    	self.endFx = self.fx
    	self.endFy = self.fy
    	self.endFz = self.fz

    def esForce(self, p):
    	# Electrostic force between self and p per coulomb's law.
	# Force on self, caused by p.
	# real force, not Rlimit limited force
	# Returns 0,0,0 instead of infinity for two particls located
	# on same spot.

    	if p is self:
	    return (0.0, 0.0, 0.0)

	dx = (self.x - p.x)
	dy = (self.y - p.y)
	dz = (self.z - p.z)

	r2,l2 = self.distance2(p)

	if r2 == 0.0:
	    return (0.0, 0.0, 0.0) # Bogus but prevents DBZ -- should be infinity

	force = self.ke * self.charge * p.charge / r2

	r = math.sqrt(r2)

	return (force * dx / r, force * dy / r, force * dz / r)

    def gravityForce(self, p):
	G = 6.67408e-11 # 2014 CODATA recommended value
	r2,l2 = self.distance2(p)
    	f = G * self.mass * p.mass / r2
	return f

    def cross(self, v1, v2):
    	# Cross product of two 3d vectors
	# returns a 3D vector
	x = v1[1]*v2[2] - v1[2]*v2[1]
	y = v1[2]*v2[0] - v1[0]*v2[2]
	z = v1[0]*v2[1] - v1[1]*v2[0]
	return (x, y, z)

    def dot(self, v1, v2):
    	# Dot product of two 3d vectors
	# returns a magnatude value
	sum = 0.0
	if len(v1) != len(v2):
	    print "Vectors of different length in dot()", v1, v2
	    sys.exit(1)
	for i in range(len(v1)):
	    sum += v1[i] * v2[i]
	return sum

    def product(self, s, v):
    	# Multiply a scaler times a 3D vector and return a vector
	return (s*v[0], s*v[1], s*v[2])

    def add(self, v1, v2):
    	return (v1[0]+v2[0], v1[1]+v2[1], v1[2]+v2[2]) 

    def subtract(self, v1, v2):
    	return (v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]) 

    def magneticField(self, p):
    	# Returns a 3D field vector B = (x,y,z)
	# Calculate the magnetic field created on self, by p.
	# B = (1e-7 q1 v1 x rHat) / r^2
	# rHat is the unit vector pointing from p to self

	(r2,l2) = self.distance2(p)

	if r2 == 0.0:
	    return (0.0, 0,0, 0.0)

	# print " distance is", r2, math.sqrt(r2)

	rHat = (self.x - p.x, self.y - p.y, self.z - p.z)
	rHat = self.product(1.0/math.sqrt(r2), rHat)

	# The books say based on current flow, this should be correct:
	# This follows the right hand rule for postive current flow
	B = self.product(1e-7 * p.charge / r2, self.cross(p.V(), rHat))

	# This is inverted 
	B = self.product(-1.0, B) # backwards

	# The correct way, means that motion causes electrons to push HARDER
	# apart from each other, and ep pairs to pull harder together.  So
	# when the velociety == c, the magnetic force equals the electostatic force.
	# If they add, as the books imply they do, it means that going the speed
	# of light means the force doubles.  But that is fucking pointless.
	# It doesn't make the speed of light special in any sense related to
	# orbital mechanics as far as I can deduce.
	# To make it special, the speed of light has to be the point where these
	# forces cancel each other out!  Which makes me logically deduce that
	# This sign has to be backwards to work correctly.
	# So I'm going to play with making it backwards from how the books all
	# say it should be to see what happens.

	return B

    def magneticForce(self, p):
    	# Returns a 3D force vector (x,y,z)
	# Calculate the force created on self, by the magnetic
	# field generated by p.
	# B = (1e-7 q1 v1 x rHat) / r^2
	# F = q2 V2 x B
	# F = q2 V2 X (1e-7 q1 v1 x rHat) / r^2
	# rHat is the unit vector pointing from p to self

	B = self.magneticField(p)

	# print "mag force"
	# print " B is", B

	F = self.product(self.charge, self.cross(self.V(), B))

	return F

    def magneticForce2(self, p):
	# Same as mag force but assume the magenetic field
	# is moving with p.  So use our relative speed
	# as our speed moving THROUGH the mag field.
    	# Returns a 3D force vector (x,y,z)
	# Calculate the force created on self, by the magnetic
	# field generated by p.
	# B = (1e-7 q1 v1 x rHat) / r^2
	# F = q2 V2 x B
	# F = q2 V2 X (1e-7 q1 v1 x rHat) / r^2
	# rHat is the unit vector pointing from p to self

	B = self.magneticField(p)

	# print "mag force"
	# print " B is", B

	relativeV = self.subtract(self.V(), p.V())

	F = self.product(self.charge, self.cross(relativeV, B))

	return F

    def magneticForceTotal(self, p, dt=None):
	return self.magneticForceTotal5(p, dt)

	# Total force on self, caused by relative self and p velociety
	# Combine the calcuation of total force into one smipler formula.
	# Force on p is the negative of this

	# Becomes:
	# F = u0/4pi q1 q2 Vx(Vxr) / r^3

	(r2,l2) = self.distance2(p)

	if r2 == 0.0:
	    # Should be infinity I guess?
	    return (0.0, 0.0, 0.0)

	r3 = r2 ** (3.0/2.0)

	relativeV = self.subtract(self.V(), p.V()) # order not important

	# r points from self to p 
	r = (p.x - self.x, p.y - self.y, p.z - self.z)
	if doMagneticInverse:
	    r = self.product(-1.0, r)
	f = self.cross(relativeV, self.cross(relativeV, r))
	F = self.product(1e-7 * self.charge * p.charge  / r3, f)

	return F

    def magneticForceTotal2(self, p):
	# Second verson for testing new ideas
	# Lets try new idea.  Mag force acts
	# to slow down relative motion parallel
	# to r vector. No what what the sign of
	# the charges, the force is always acting
	# against forward motion.
	# It's equal and opposit on the two paricles.
	# so what we calucate for one is just the
	# invese of what it is for the other.
	#  What force we add to make it slow down
	# We must also take away from ES force
	# to keep total force on the particle the same,
	# after we sum ES and MAG.  So this MAG effect
	# is really just twisting the ES force field.
	# AKA DISTORTING THE ES FORCE FIELD? :)
	# Maybe that's relativity right there???
	# By twising insted of adding new forces,
	# we mantain potential vs ke energy truth.
	# We aren't creating a new potential energy
	# force field to store mag energy.
	# Idea, is that when two particles pass
	# Parallel to each other, at the speed of light
	# The force acting to slow it down will be the
	# full ES force and the old ES force will be
	# down to zero.  So we will have twisted the
	# ES field a full 90 deg at that point.

	# So to code, find magnatde of v perperndicular to r.
	# is that v dot rHat?
	# Adjust as precent relative ot the speed of light.
	# Divide by v/c.  or v^2/c^2?

	relativeV = self.subtract(self.V(), p.V()) # order not important
	r = (p.x - self.x, p.y - self.y, p.z - self.z)

	# Total force on self, due to other particle p

	# Becomes:
	# F = u0/4pi q1 q2 Vx(Vxr) / r^3

	(r2,l2) = self.distance2(p)

	if r2 == 0.0:
	    # Should be infinity I guess?
	    return (0.0, 0.0, 0.0)

	r3 = r2 ** (3.0/2.0)

	relativeV = self.subtract(self.V(), p.V()) # order not important

	if True:
	    # new ES twist to slow down logic sort of.
	    # r points from self to p 

	    r = (p.x - self.x, p.y - self.y, p.z - self.z)
	    rHat = self.product(1.0/magnatude(r), r)
	    mag = self.cross(self.cross(relativeV, rHat), rHat)

	    # Ok, fucking messy with abs() and magnatude(V) to get v^2.
	    # But leave it for now.  Try it, and if it looks good, look for way
	    # to simplify the math later.

	    magF = self.product(1e-7 * abs(self.charge * p.charge) * magnatude(relativeV) / r2, mag)

	    # So, magF if I coded it correctly, is perpendicular to r, in plane of V.
	    # acting against velociety to slow it down in the direction perpendicular to r.
	    # But also need to reduce ES by this same magnatude to keep total force the same.
	    # OHHH NOO. That's not that simple.  That won't keep total the same!
	    # It won't keep the the magnatude of the force vector the same.
	    # OK -- decided to punt and try it anyway.  These are v^2 terms, so maybe just maybe
	    # there is justification for doing it this way?
	    # So, magF, is the force vector, 90 deg to r.  now I have to reduce r by this same amount.
	    # So I have to add a vector of this same length, pointing in rHat direction.

	    esAdjustF = self.product(magnatude(magF), rHat)
	    if self.charge * p.charge < 0:
	    	esAdjustF = self.product(-1.0, esAdjustF)
	    F = vectorSum(magF, esAdjustF)

	    if False:
		print "TotalForce2"
		print " self.V() is ", self.V(), magnatude(self.V())
		print " p.V() is    ", p.V(), magnatude(p.V())
		print " relativeV is", relativeV, magnatude(relativeV)
		print " r is        ", r
		print " rhat is     ", rHat, "magnatude", magnatude(rHat)
		print " magF is     ", magF, "magnatude", magnatude(magF)
		print " esAdjustF is", esAdjustF, "magnatude", magnatude(esAdjustF)
		print " F is        ", F, "magnatude", magnatude(F)
		print
	else:
	    # Old first way
	    # r points from self to p 
	    r = (p.x - self.x, p.y - self.y, p.z - self.z)

	    if doMagneticInverse:
		r = self.product(-1.0, r)
	    # f = self.cross(self.V(), self.cross(p.V(), r))
	    f = self.cross(relativeV, self.cross(relativeV, r))
	    F = self.product(1e-7 * self.charge * p.charge  / r3, f)

	return F

    def magneticForceTotal3(self, p, dt=None):
	# Thrid verson for testing new ideas for magnetic force

	# -- THIS IS BORKEN. Tried to do what I'm doing in Total 4
	# then tried to turn it into DF/dt -- but failed to calcuate
	# that correctly and now I've given up.  Because the code
	# below is not getting the signs right becaues I'm not
	# calculating F using vectors and the derivivae of F is
	# not using vectors correctly!
	# So I'm giving up beuase I don't like this idea anyhow!
	# Leving it becuase I might come back to it some day.

	# dF/dt = (- c^2 1e7 q1 q2 / 2 r^3) v dot r
	# Error!  Should have been:
	# dF/dt = (-2 c^2 1e7 q1 q2 / r^3) v dot rHat

	(r2,l2) = self.distance2(p)

	if r2 == 0.0:
	    # Should be infinity I guess?
	    return (0.0, 0.0, 0.0)

	# relativeV = self.subtract(self.V(), p.V())
	relativeV = self.subtract(p.V(), self.V())

	r3 = r2 ** (3.0/2.0)

	r = (p.x - self.x, p.y - self.y, p.z - self.z)
	rHat = self.product(-1.0/magnatude(r), r)
	# rHat points from p back to self
	# rHat * self.q * self.q must define force on self

	# dr = self.dot(relativeV, rHat)
	# df = -2.0 * self.ke * self.charge * p.charge * dr / r3
	# magFactor = 1.0/(self.c*self.c)
	# F = self.product(df*magFactor, rHat)

	dr = relativeV
	factor = -2.0 * self.ke * self.charge * p.charge / r3
	df = self.product(factor, dr)

	magFactor = 1.0/(self.c*self.c)
	F = self.product(magFactor, df)

	if True:
	    print "ForceTotal3"
	    print " self.V() is ", self.V(), magnatude(self.V())
	    print " p.V() is    ", p.V(), magnatude(p.V())
	    print " relativeV is", relativeV, magnatude(relativeV)
	    print " r is        ", r
	    print " rhat is     ", rHat, magnatude(rHat)
	    es = self.esForce(p)
	    print " esForce is  ", es, magnatude(es)
	    if dt is not None:
		print " dt is       ", dt
	    print " dr/dt is    ", dr
	    if dt is not None:
		print " dr/dt * dt  ", self.product(dt, dr)
		print " dr/dt * dt m", magnatude(dr)*dt
	    print " df/dt is    ", df
	    if dt is not None:
		print " df/dt * dt  ", self.product(dt, df)
		print " df/dt * dt m", magnatude(df)*dt
	    print " F is        ", F, magnatude(F)
	    print

	return F

    def magneticForceTotal4(self, p, dt=None):
	# Forth verson for testing new ideas for magnetic force
	# This is what I tried to code with Total3 but then
	# relized was thinking about it all wrong.  I
	# want to calucate how the strenght of E is changing
	# over time, and then modify that strenth, but not
	# the direction of of the force vector, as a a function
	# of how fast the strength of E is changing! aka
	# d(magnatude(e))/dt.

	# Calculate D|e|/dt and make magenetic force
	# Nothing more than an increase in the ES force based
	# on D|e|/dt.
	# This is a very different approach, but yet seems like
	# it could produces
	# the same sort of results for current -- aka the
	# sum of many electons moving at once.  But it has
	# the intersting effect of having no magnetic force
	# at all when the two particles pass side by side
	# becuase de/dt = 0 at that point!  Which could be
	# useful in not messing up orbits!
	# And it might force eleptical high speed orbits into
	# circles.

	# d|F|/dt = (-2 c^2 1e7 q1 q2 / r^3) v dot rHat

	(r2,l2) = self.distance2(p)

	if r2 == 0.0:
	    # Should be infinity I guess?
	    return (0.0, 0.0, 0.0)

	# relativeV = self.subtract(p.V(), self.V())
	relativeV = self.subtract(self.V(), p.V())

	r3 = r2 ** (3.0/2.0)

	r = (p.x - self.x, p.y - self.y, p.z - self.z)
	rHat = self.product(-1.0/magnatude(r), r)
	# rHat points from p back to self
	# rHat * self.q * self.q must define force on self

	# dr = self.dot(relativeV, rHat)
	# df = -2.0 * self.ke * self.charge * p.charge * dr / r3
	# magFactor = 1.0/(self.c*self.c)
	# F = self.product(df*magFactor, rHat)

	es = self.esForce(p)
	dr = self.dot(relativeV, rHat)
	beta2 = (dr / self.c) ** 2
	F = self.product(beta2, es)

	if False:
	    print "ForceTotal4"
	    print " self.V() is ", self.V(), magnatude(self.V())
	    print " p.V() is    ", p.V(), magnatude(p.V())
	    print " relativeV is", relativeV, magnatude(relativeV)
	    print " r is        ", r
	    print " rhat is     ", rHat, magnatude(rHat)
	    es = self.esForce(p)
	    print " esForce is  ", es, magnatude(es)
	    if dt is not None:
		print " dt is       ", dt
	    print " dr/dt is    ", dr
	    if dt is not None:
		print " dr/dt * dt  ", dr * dt
	    print " df/dt is    ", df
	    if dt is not None:
		print " df/dt * dt  ", df * dt
	    print " F is        ", F, magnatude(F)
	    print

	return F

    def magneticForceTotal5(self, p, dt=None):
    	# Fith version for testing yet another magnatism
	# idea.  This one is based on the idea that magnatism
	# needs to translate the force field into kenetic
	# energy in a separate dimention from E.  But
	# when in an orbit, the idea is not to speed or slow
	# down the orbit -- that's the dimension E is using
	# store ke in the orbit.  And not to make the orbting
	# particle go into a higher or lower orbit -- again
	# that's the same dimension as E is using. But instead
	# Make it turn, say from an equator orbit, to a polar
	# orbit!  So the turn doesn't mess up the kenetic energy
	# of the E orbit at all!  But instead adds NEW kenetic
	# energy of a complex sprial or spinning orbit, or something
	# complex I can't even grasp at the moment!  But a separate
	# kenetic energy store for the E orbit!

	# So, to do this.  We apply the force of the B field 
	# at 90 degree to R and 90 deg to (relaveV)! aka vxr.
	# AKA, what B flux lines are, but not how B force is
	# described! 

	# But, we are going to guess that the mangnatude of
	# B should be v^2/c^2 relative to E strength.  Not
	# with V reduced by vxrHat. (aka using it's full
	# velociety not it's sin theta reduced velociety.
	# EDIT -- coded vxr instead. It's easier. Cleaner.

	# And it must be equal and opposit of course.
	# so p1.mag(p2) is the inverse of p2.mag(p1).

	# d|F|/dt = (-2 c^2 1e7 q1 q2 / r^3) v dot rHat

	(r2,l2) = self.distance2(p)

	if r2 == 0.0:
	    # Should be infinity I guess?
	    return (0.0, 0.0, 0.0)

	# relativeV = self.subtract(p.V(), self.V())
	# relativeV = self.subtract(self.V(), p.V())

	# r3 = r2 ** (3.0/2.0)

	# r = (p.x - self.x, p.y - self.y, p.z - self.z)
	# rHat = self.product(-1.0/magnatude(r), r)

	# rHat points from p back to self
	# rHat * self.q * self.q must define sign of force on self?

	if False:
	    # Old attempt
	    b = self.cross(relativeV, r)
	    factor = 1e-7 * self.charge * p.charge * magnatude(relativeV) / r3
	    if self.charge < 0:
		factor *= -1.0 # well, needed to make ep pair push opposit directions!
	    F = self.product(factor, b)

	# So it's 1e-7 q * q * v * v / r^2 in total whcih gets all the unints
	# consitent with E. But in the direction of v x r.

	if False:
	    # Try making B driven by dE/dt. The faster E is changing, the
	    # strong the B field will be.
	    # Keep B at 90 deg to E.  Seems to be required.  But
	    # we can point it either at vxr, so it's perpendicular to
	    # r AND v. Or we can be in the same plane with v and r, while
	    # being perpendicular to R still.
	    # Lets try vxr first.
	    # And I really mean d|E|/dt, not dE/dt.  
	    #### NOTE: from above: d|F|/dt = (-2 c^2 1e7 q1 q2 / r^3) v dot rHat
	    dr = self.dot(relativeV, rHat)
	    # df = -2.0 * self.ke * self.charge * p.charge * dr / r3
	    # Figured out how to convert Dr into Force!  Stupid me for not
	    # seeing this before.  Dr is V!  And we know the formula is v^2!
	    df = self.ke * self.charge * p.charge * dr * dr / r2
	    #### [[[ error above, should be 1e-7 not self.ke?? ]]]]
	    b = self.cross(relativeV, rHat)
	    F = self.product(df, b)
	    if True:
		print "ForceTotal5"
		print " self.V() is ", self.V(), magnatude(self.V())
		print " p.V() is    ", p.V(), magnatude(p.V())
		print " relativeV is", relativeV, magnatude(relativeV)
		print " r is        ", r
		print " rhat is     ", rHat, magnatude(rHat)
		es = self.esForce(p)
		print " esForce is  ", es, magnatude(es)
		print " dr is       ", dr
		print " df is       ", df
		print " b is        ", b, magnatude(b)
		print " F is        ", F, magnatude(F)

	if True:
	    # Total5(C) -- third attempt coded in total5.
	    # Ok, figured out we can not use vxr as the direction
	    # of B. It makes equal and opposit impossible for ++ and --
	    # paris.  But making V in the plane with v and r, while
	    # 90 deg to E is possible.  So lets do that!  We already
	    # tried a version of this in Total2()  But we return.
	    # The difference is that we use V dot r, instead of V x r
	    # this time.  That means this is maximal B when the two
	    # particles are closing on each other the fastest - which
	    # makes them serve away BTW and not run into each other.
	    # I would think.

	    # Think of p is being at the orign standing still.
	    # self particles is elsewhere and moving.

	    relativeV = self.subtract(self.V(), p.V())

	    # Sign of relativeV is of the velcoity of self if the
	    # the velociaty of p is zero.

	    r = (self.x - p.x, self.y - p.y, self.z - p.z)
	    rHat = self.product(1.0/magnatude(r), r)

	    # r points from p (logically at orign) to self.

	    # Magnatude of v in line with r
	    vr = self.dot(relativeV, rHat)

	    vHat = self.product(1.0/magnatude(relativeV), relativeV)
	    bHat = self.cross(self.cross(vHat, rHat), rHat)
	    bMag = magnatude(bHat)
	    if bMag != 0.0:
		bHat = self.product(1.0/bMag, bHat)
		# Otherwise, leave it as 0,0,0 and let it
		# return F of zero.
		# This is a problem.  It happens because we don't
		# know which direction to point B!  R and V are
		# in the same, so we don't know which direction
		# is both 90 deg to R and in the same plane as V.
		# But yet, at this point, B should be maximal value!
		# This brings this whole idea under question as to
		# whether this is logically valid to begin with.
	    factor = 1.0e-7 * self.charge * p.charge * vr * vr / r2
	    F = self.product(factor, bHat)
	    # F = self.product(-1.0, F) # backwards

	    if False:
		print "ForceTotal5"
		print "self x y is  ", self.x/Angstrom, self.y/Angstrom
		print "P   x y is   ", p.x/Angstrom, p.y/Angstrom
		print " self.V() is ", self.V(), magnatude(self.V())/self.c
		print " p.V() is    ", p.V(), magnatude(p.V())/self.c
		print " relativeV is", relativeV, magnatude(relativeV)
		print " VHat is     ", vHat, magnatude(vHat)
		print " r is        ", r
		print " rhat is     ", rHat, magnatude(rHat)
		es = self.esForce(p)
		print " esForce is  ", es, magnatude(es)
		print " vr is       ", vr
		print " bHat is     ", bHat, magnatude(bHat)
		print " factor is   ", factor
		print " F is        ", F, magnatude(F)
		print " F dot rHat  ", self.dot(F, rHat)

	if False:
	    # Hard Code fake mag force at 90 deg to v and r for an electon
	    # only, at 1/2 the force of E.
	    F = (0.0, 0.0, 0.0)
	    if isinstance(self, Electron):
		eForce = abs(self.ke * self.charge * p.charge / r2)
		vHat = self.product(1.0/magnatude(relativeV), relativeV)
		b = self.cross(vHat, rHat)
		bHat = self.product(1.0/magnatude(b), b)
		F = self.product(eForce, bHat)
		#print "v is", self.V()
		#print "rhat is", rHat
		#print "bHat is", bHat
		#print "eForce is", eForce
		#es = self.esForce(p)
		#print " esForce is  ", es, magnatude(es)
		#print "F    is", F
		#sys.exit(1)

	return F

    def addEndForce(self, p):
    	if p is self:
	    return

	dx = (self.endX - p.endX)
	dy = (self.endY - p.endY)
	dz = (self.endZ - p.endZ)

	r2,l2 = self.endDistance2(p)

	force = self.ke * (self.charge * p.charge) / l2

	r = math.sqrt(r2)

	self.endFx += force * dx / r
	self.endFy += force * dy / r
	self.endFz += force * dz / r

	if doMagnetic:
	    f = self.magneticForceTotal(p)
	    self.endFx += f[0]
	    self.endFy += f[1]
	    self.endFz += f[2]

    def calculateEndVelocity(self, dt):
	# Assume linear change in acceleration from start (fx to end endFx)
	# (yes this is the correct intergral of a linear chagne in acceleration)
	# I had to recalcuate it 10-4-2016 to verify

	self.endVx = self.vx + ((self.fx + self.endFx) / 2.0) * dt / self.mass
	self.endVy = self.vy + ((self.fy + self.endFy) / 2.0) * dt / self.mass
	self.endVz = self.vz + ((self.fz + self.endFz) / 2.0) * dt / self.mass

    def calculateEndPosition(self, dt): # Calcluate end X Y Z
	# Calculate ending position using both start and end velocity

	# Assume force (acceleration) changes but is linear from start to end
	# x = 1/2 a t^2 + vt + x
	# a is (2*as + ae)/3  --- where as is a start, and ae is a end.
	# endx = 1/2 (2as + ae)/3 t^2 + v t + x

	# self.endX = self.x + self.vx * dt + 0.5 * (2.0*self.fx + self.endFx)/(3.0*self.mass) * dt ** 2.0

	self.endX = self.x + self.vx * dt + (self.fx + 0.5*self.endFx)/(3.0*self.mass) * dt ** 2.0
	self.endY = self.y + self.vy * dt + (self.fy + 0.5*self.endFy)/(3.0*self.mass) * dt ** 2.0
	self.endZ = self.z + self.vz * dt + (self.fz + 0.5*self.endFz)/(3.0*self.mass) * dt ** 2.0

    def move(self):
	# Make end state the current state
	# Save current state as old state
	# Leaves ending force the same as the starting

	self.x = self.endX
	self.y = self.endY
	self.z = self.endZ

	self.vx = self.endVx
	self.vy = self.endVy
	self.vz = self.endVz

	self.fx = self.endFx
	self.fy = self.endFy
	self.fz = self.endFz

    def resetState(self):
	# Reset so we can recompute step with new DT
	# Reset force end to match force begin
	# Evertyhing else will be recomputed again.

	self.endFx = self.fx
	self.endFy = self.fy
	self.endFz = self.fz

    def keneticEnergy(self):
	# print "KE CALC BEGIN"
	return self.keneticEnergyCalc(self.vx, self.vy, self.vz)

    def keneticEndEnergy(self):
	# print "KE CALC END"
	return self.keneticEnergyCalc(self.endVx, self.endVy, self.endVz)

    def keneticEnergyCalc(self, vx, vy, vz):
    	## 1/2 m v**2
	ke = 0.5 * self.mass * (vx ** 2.0 + vy ** 2.0 + vz ** 2.0)
	# print "KE CALC vx,vy,vz:", vx, vy, vz
	# print "KE CALC answer =", ke
	return ke

    def setKeneticEnergy(self, ke):
    	# Back calculate velocity using given ke -- keep direction the same
	newV2 = ke / (0.5 * self.mass)
	oldV2 = (self.vx ** 2.0 + self.vy ** 2.0 + self.vz ** 2.0)
	# print "in set kenetic newV2 is", newV2
	# print "in set kenetic oldV2 is", oldV2
	newV = math.sqrt(newV2)
	oldV = math.sqrt(oldV2)
	#self.vx *= newV2 / oldV2
	#self.vy *= newV2 / oldV2
	#self.vz *= newV2 / oldV2
	self.vx *= newV / oldV
	self.vy *= newV / oldV
	self.vz *= newV / oldV

    def distance2(self, p): # distance squared

    	if p is self:
	    return 0.0

	dx = (self.x - p.x)
	dy = (self.y - p.y)
	dz = (self.z - p.z)

	d2 = dx ** 2.0 + dy ** 2.0 + dz ** 2.0

	return self.limitedDistance2(d2)

    def endDistance2(self, p): # distance squared

    	if p is self:
	    return 0.0

	dx = (self.endX - p.endX)
	dy = (self.endY - p.endY)
	dz = (self.endZ - p.endZ)

	d2 = dx ** 2.0 + dy ** 2.0 + dz ** 2.0

	return self.limitedDistance2(d2)

    def limitedDistance2(self, d2):

    	# Limit distance to RLimit to solve computational problems.
	# return (real, limited) tuple

	return (d2, max(d2, RLimit ** 2))

    def distance(self, p):
	r,l = self.distance2(p)
	return (math.sqrt(r), math.sqrt(l))

    def endDistance(self, p):
	r,l = self.endDistance2(p)
	return (math.sqrt(r), math.sqrt(l))

    def potentialEnergy(self, p):
    	# potential energy between self and particle P

    	if p is self:
	    return 0.0	# Bogus should be +infinity

	r,l = self.distance(p)

	return self.potentialEnergyForDistance(p, r)

    def potentialEndEnergy(self, p):
    	# potential energy between self and particle P

    	if p is self:
	    return 0.0	# Bogus should be +infinity

	r,l = self.endDistance(p)

	return self.potentialEnergyForDistance(p, r)

    def potentialEnergyForDistance(self, p, d):

	# if d == 0:
	    # return 0.0	# Bogus should be +infinity

	if d >= RLimit:
	    return self.ke * self.charge * p.charge / d

	global InsideRLimitCount
	InsideRLimitCount += 1

	x = self.ke * self.charge * p.charge / RLimit

	return x + (x / RLimit) * (RLimit - d)

	# self.charge = -1.60218e-19 # in Coulombs
	# self.ke = 8.9875517873681764e9  # Coulomb's constant (1/4 pi e) written as K(sub)e


    def momentum(self):
	# Return (mx,my,mz) tuple
    	return self.mass * self.vx, self.mass * self.vy, self.mass * self.vz

    def addMomentum(self, m):
    	self.vx += m[0] / self.mass
    	self.vy += m[1] / self.mass
    	self.vz += m[2] / self.mass

    def addVelocity(self, v):
    	self.vx += v[0]
    	self.vy += v[1]
    	self.vz += v[2]

class Electron(Particle):
    def __init__(self, x=0.0, y=0.0, z=0.0):
	Particle.__init__(self, x, y, z)
	self.charge = -1.60218e-19 # in Coulombs
	self.mass = 9.10938356e-31
	self.symbol = 'e'
	if FakeConstants:
	    self.charge = -1.0
	    self.mass = 1.0

class Proton(Particle):
    def __init__(self, x=0.0, y=0.0, z=0.0, n=1.0):
	Particle.__init__(self, x, y, z)
	self.charge = n * +1.60218e-19 # in Coulombs
	self.mass = n * 1.672621898e-27
	self.symbol = 'p'
	if FakeConstants:
	    self.charge = +1.0
	    # Keep real ratio the same -- mass of electon is 1.0
	    # mass of proton is 1836.15267376
	    self.mass = 1.672621898e-27 / 9.10938356e-31 # units for mass e == 1.0


global ResetEnergy
ResetEnergy = False

class ParticleImage:
    def __init__(self, p):
	self.p = p # Particle

    def display(self, zMin, zMax):

	x = self.spaceToPixels(self.p.x)
	y = self.spaceToPixels(self.p.y)
	z = self.spaceToPixels(self.p.z)

	if isinstance(self.p, Electron):
	    color = black
	    size = 2
	else:
	    color = red
	    size = 4

	minScale = 1.0
	maxScale = 3.0
	size *= (z / float(screen_depth)) * (maxScale-minScale) + minScale
	size = abs(int(size))


	inset = 10
	if isinstance(self.p, Proton):
	    inset = 40

	eChange = 0.25
	eChange = 1.00

	global ResetEnergy
	bounce = False
	if x < inset and self.p.vx < 0:
	    self.p.vx *= -1
	    self.p.setKeneticEnergy(self.p.keneticEnergy()*eChange)
	    ResetEnergy = True
	    self.p.x = self.pixelsToSpace(inset)
	    bounce = True
	if x > screen_width-inset and self.p.vx > 0:
	    self.p.vx *= -1
	    self.p.setKeneticEnergy(self.p.keneticEnergy()*eChange)
	    ResetEnergy = True
	    self.p.x = self.pixelsToSpace(screen_width - inset)
	    bounce = True
	if y < inset and self.p.vy < 0:
	    self.p.vy *= -1
	    self.p.setKeneticEnergy(self.p.keneticEnergy()*eChange)
	    ResetEnergy = True
	    self.p.y = self.pixelsToSpace(inset)
	    bounce = True
	if y > screen_height-inset and self.p.vy > 0:
	    self.p.vy *= -1
	    self.p.setKeneticEnergy(self.p.keneticEnergy()*eChange)
	    ResetEnergy = True
	    self.p.y = self.pixelsToSpace(screen_height - inset)
	    bounce = True
	if z < inset and self.p.vz < 0:
	    self.p.vz *= -1
	    self.p.setKeneticEnergy(self.p.keneticEnergy()*eChange)
	    ResetEnergy = True
	    self.p.z = self.pixelsToSpace(inset)
	    bounce = True
	if z > screen_depth-inset and self.p.vz > 0:
	    self.p.vz *= -1
	    self.p.setKeneticEnergy(self.p.keneticEnergy()*eChange)
	    ResetEnergy = True
	    self.p.z = self.pixelsToSpace(screen_depth - inset)
	    bounce = True

	global eBounceCount
	global pBounceCount

	if bounce:
	    zeroMomentum(world) # fix momentum
	    if isinstance(self.p, Proton):
	    	pBounceCount += 1
	    else:
	    	eBounceCount += 1

	# Notice -- the way we change position below
	# to move particle back inside window frame without
	# adjusting velocity changes the total energy in the system.
	# So setting eChange = 1.0 does not conserve energy correctly.
	# We adjust the systems total target for fixing energy
	# on a bounce which forces us to accept this broken
	# energy total as correct.
	# But if we turn off the Bounce check, that allows the energyFix
	# system to keep fixing this error for us.  Hince, the test
	# below to turn Bounce flag off if eChange is 1.00

	if eChange == 1.0:
	    ResetEnergy = False # Don't reset energy total -- fix it instead

	x = self.spaceToPixels(self.p.x)
	y = self.spaceToPixels(self.p.y)

	# print "x y is", x, y
    	pygame.draw.circle(screen, color, (x, y), size, 0)

    def spaceToPixels(self, space):
	# 0,0 is the same in both and is the top left corner of the screen
	return int(pixelsPerAngstrom * space / Angstrom)

    def pixelsToSpace(self, pixels):
	return pixels * Angstrom / pixelsPerAngstrom

	
def vectorSum(a, b):
    # breaks if vectors not the same length
    l = max(len(a), len(b))
    s = [0.0]*l
    for i in range(l):
    	s[i] = a[i] + b[i]
    return tuple(s)

def totalMomentum(world):
    s = (0.0, 0.0, 0.0)
    for i in range(len(world)):
    	s = vectorSum(s, world[i].momentum())
    return s

def totalKeneticEnergy(world):
    totalKE = 0.0

    for i in range(len(world)):
	totalKE += world[i].keneticEnergy() 

    return totalKE

def totalPotentialEnergy(world):
    totalPE = 0.0

    for i in range(len(world)):
	for j in range(i+1, len(world)):
	    totalPE += world[i].potentialEnergy(world[j])

    return totalPE

def totalEndKeneticEnergy(world):
    totalKE = 0.0

    for i in range(len(world)):
	totalKE += world[i].keneticEndEnergy() 

    return totalKE

def totalEndPotentialEnergy(world):
    totalPE = 0.0

    for i in range(len(world)):
	for j in range(i+1, len(world)):
	    totalPE += world[i].potentialEndEnergy(world[j])

    return totalPE

#####################################################################
# Normalize momentum
#####################################################################

def zeroMomentum(world):
    ### Normalize monuntum to zero to freeze frame of referece
    tm = totalMomentum(world)
    n = len(world)
    totalMass = 0.0
    for i in range(n):
	totalMass += world[i].mass
    fudge = (-tm[0]/totalMass, -tm[1]/totalMass, -tm[2]/totalMass)
    for i in range(n):
	world[i].addVelocity(fudge)

#####################################################################
### Move objects to place center of mass in the middle of the screen
#####################################################################

def centerMass(world):
    centerX = (screen_width / pixelsPerAngstrom * Angstrom) / 2.0
    centerY = (screen_height / pixelsPerAngstrom * Angstrom) / 2.0
    centerZ = (screen_depth / pixelsPerAngstrom * Angstrom) / 2.0
    cx = cy = cz = 0.0
    tm = 0.0
    for p in world:
    	cx += p.x * p.mass
    	cy += p.y * p.mass
    	cz += p.z * p.mass
	tm += p.mass
    for p in world:
    	p.x = p.x - cx / tm + centerX
    	p.y = p.y - cy / tm + centerY
    	p.z = p.z - cz / tm + centerZ

def centerOfMass(world):
    cx = cy = cz = 0.0
    tm = 0.0
    for p in world:
    	cx += p.x * p.mass
    	cy += p.y * p.mass
    	cz += p.z * p.mass
	tm += p.mass
    x = cx / tm
    y = cy / tm
    z = cz / tm
    return (x, y, z)

    
# fastTest()
# neutronGravityTest()
# magneticTest()
# forceCircleTest()
# magCircleTest()

screen = pygame.display.set_mode(screen_size)
clock = pygame.time.Clock()
pygame.display.set_caption('Physics')

p1 =   Proton(Angstrom * 0.0, 0.0, 0.0 * Angstrom, n=10.0)
e1 = Electron(Angstrom * 0.25, 0.0, 0.0 * Angstrom)
e2 = Electron(Angstrom * -0.25, 0.0 * Angstrom, 0.0 * Angstrom)

e1.vy = 200000.0
e1.vy = 100000.0
e1.vy = 0.0
e1.vy = 1600000.0
e1.vy = 16000000.0
# e1.vx = 800000.0
e1.vy = 3000000.0


# This is what the below calculates for the perfect circular orbit
# Velocety for the ep pair spaced at 0.25A
e1.vy = 3181993.44316
p1.vy = -3181993.44316 * e1.mass / p1.mass
e2.vy = -3181993.44316
e2.vz = -3181993.44316/10
# e1.vy = p1.vy = 0.0
# e1.vz = 800000.0

# zzz
if False: # I have no clue what this code does 5-11-2018 CW
    r = Angstrom * 0.25
    print "r is", r
    r = e1.x - p1.x
    print "r is", r
    rCenter = r * p1.mass / (p1.mass + e1.mass)
    e1.vz = e1.c * math.sqrt(abs(1e-7 * e1.charge * p1.charge * rCenter/ (r * r * e1.mass)))
    rCenter = r * e1.mass / (p1.mass + e1.mass)
    p1.vz = -p1.c * math.sqrt(abs(1e-7 * e1.charge * p1.charge * rCenter/ (r * r * p1.mass)))
    print "p1.vz is", p1.vz, "momentum is", p1.momentum()
    print "e1.vz is", e1.vz, "momentum is", e1.momentum()
    print "p1.vz - e1.vz", p1.vz - e1.vz

    p1.vy = p1.vz
    e1.vy = e1.vz
    p1.vz = 0.0
    e1.vz = 0.0
    e1.vy /= 2.0

# sys.exit(1)
# e1.vz = 1000000.0

# Does adding a third electon away from an orbiting pair get sucked in?
# p2 = Proton(100.0 * Angstrom, 0.0 * Angstrom, 0.0 * Angstrom)
# e2 = Electron(100.25 * Angstrom, 0.0 * Angstrom, 0.0 * Angstrom)
# e2.vy = e1.vy # copy orbital velocity for second pair
# p2.vy = p1.vy


# p2 =   Proton(Angstrom * 0.5, Angstrom * 0.0,  0.0 * Angstrom)
# e2 = Electron(Angstrom * 1.5, Angstrom * 0.0, -0.5 * Angstrom)
#e2.vy = 1600000.0
#e2.vy = 800000.0

p3 =   Proton(Angstrom * 6.0, Angstrom * 0.0, 0.0)
e3 = Electron(Angstrom * 7.0, Angstrom * 0.0, 0.0)
e3.vy = 800000.0
e3.vy = 1600000.0

piworld = []

if True:
    pi1 = ParticleImage(p1)
    piworld.append(pi1)
    pi2 = ParticleImage(e1)
    piworld.append(pi2)
    # pi3 = ParticleImage(p2)
    # piworld.append(pi3)
    pi4 = ParticleImage(e2)
    piworld.append(pi4)

if False:
    pi3 = ParticleImage(p2)
    piworld.append(pi3)
    if False:
	pi4 = ParticleImage(e2)
	piworld.append(pi4)

if False:
    pi5 = ParticleImage(p3)
    piworld.append(pi5)
    pi6 = ParticleImage(e3)
    piworld.append(pi6)

if False: # Two electons
    e1 = Electron(Angstrom * 0.1, Angstrom * 1.0, 0.0)
    piworld.append(ParticleImage(e1))
    e2 = Electron(Angstrom * 5.1, Angstrom * 1.0, 0.0)
    piworld.append(ParticleImage(e2))

if False:
    # Random particles

    p = 2
    e = 2
    percentOfScreen = 0.10
    e1 = Electron() # Just need any particle
    monumtum = e1.mass * e1.c / 1000.0
    world = []
    xwidth = (screen_width * percentOfScreen / pixelsPerAngstrom) * Angstrom
    ywidth = (screen_height * percentOfScreen / pixelsPerAngstrom) * Angstrom

    for i in range(p):
	x = random.random() * xwidth
	y = random.random() * ywidth
	z = random.random() * min(xwidth, ywidth)
	# z = 0.0
    	p = Proton(x, y, z)
    	world.append(p)
	p.vx = random.random() * monumtum / p.mass
	p.vy = random.random() * monumtum / p.mass
	p.vz = random.random() * monumtum / p.mass

    for i in range(e):
	x = random.random() * xwidth
	y = random.random() * ywidth
	z = random.random() * min(xwidth, ywidth)
	# z = 0.0
    	p = Electron(x, y, z)
    	world.append(p)
	p.vx = random.random() * monumtum / p.mass
	p.vy = random.random() * monumtum / p.mass
	p.vz = random.random() * monumtum / p.mass

    for p in world:
    	piworld.append(ParticleImage(p))
    	

world = []
for p in piworld:
    world.append(p.p)
	
lastKE = 0.0
lastPE = 0.0

zeroMomentum(world)
centerMass(world)
# e2.x = 40 * Angstrom

#####################################################################
### Calucate all initial forces
### Sets starting and ending forces at the same time
#####################################################################

for p1 in world:
    p1.zeroForce()
    for p2 in world:
	p1.addForce(p2)

startingTotalKE = totalKeneticEnergy(world) 
startingTotalPE = totalPotentialEnergy(world)

#####################################################################
# Main draw and simulation loop
#####################################################################

fps_limit = 60
run_me = True
i = 0
cycleCount = 0.0
now = 0.0
energyDiffMax = None
maxVc = 0.0

lastD = 0.0
lastNow = now
lastV = 0.0
lastA = 0.0


while run_me:
    clock.tick(fps_limit)
    for event in pygame.event.get():
	if event.type == pygame.QUIT:
	    run_me = False

    screen.fill(white)

    zMin = None
    zMax = None
    for p in piworld:
	z = p.p.z
    	if zMin is None or z < zMin:
	    zMin = z
    	if zMax is None or z > zMax:
	    zMax = z

    slist = sorted(piworld, key=attrgetter('p.z'))
    for p in slist:
	p.display(zMin, zMax)

    if False:
	for p in piworld:
	    if isinstance(p.p, Proton):
		p.display(zMin, zMax)
	for p in piworld:
	    if isinstance(p.p, Electron):
		p.display(zMin, zMax)

    pygame.display.flip()

    ###
    ### Start of physics simulation step loop
    ###

    crtClearAndHome()

    print
    print "Time now is %25.40f" % now
    print "Total Momentum %8.1e %8.1e %8.1e" % totalMomentum(world)
    print
    print "doMagnetic:", doMagnetic, "  doMagneticInverse:", doMagneticInverse
    print

    totalKE = totalKeneticEnergy(world)
    totalPE = totalPotentialEnergy(world)

    if ResetEnergy:
	# Bounce happaned on display above
	# Bounce will remove energy, we need to cope...
	startingTotalKE = totalKE
	startingTotalPE = totalPE
	ResetEnergy = False

    re = ((totalKE - startingTotalKE) + (totalPE - startingTotalPE))

    print "Total ke     %8.1e" % totalKE, "change from last %8.1e" % (totalKE - lastKE)
    print "Total pe     %8.1e" % totalPE, "change from last %8.1e" % (totalPE - lastPE)
    print "Total    e:  %8.1e" % (totalKE + totalPE)
    print "Relative e:  %8.1e" % (re),
    print "  %% of Total ke:%8.4f" % (abs(re*100.0 / totalKE))
    print
    print "DT is: %4.1e" % dt
    print
    print "PixelsPerAngstrom", pixelsPerAngstrom,
    print "Screen (%.1fx%.1f) A" % (screen_width/pixelsPerAngstrom, screen_height/pixelsPerAngstrom)
    print

    print "Inside Rlimit ", InsideRLimitCount, " pBounce:", pBounceCount, " eBounce:", eBounceCount
    print

    lastKE = totalKE
    lastPE = totalPE

    cnt = 0
    for i in range(len(world)):
	p1 = world[i]
	if not isinstance(p1, Proton):
	    continue
	for j in range(i+1, len(world)):
	    p2 = world[j]
	    if not isinstance(p2, Proton):
		continue
	    print "Distance between",
	    print "P%02d P%02d %11.6f" % (i, j, p1.distance(p2)[0]/Angstrom)
	    cnt += 1
	    if cnt > 10:
		break
	if cnt > 10:
	    break
    print

    ###########################################
    # Debug print out particle stats
    ###########################################

    totalAvgKE = 0.0
    for i in range(len(world)):
	p1 = world[i]
	p1.avgKE += (p1.keneticEnergy() - p1.avgKE) * 0.0001
	totalAvgKE += p1.avgKE

    for i in range(len(world)):
	p1 = world[i]
	sys.stdout.write(p1.symbol)
	vc = magnatude(p1.V())/p1.c
	maxVc = max(maxVc, vc)
	print "%d vx:%10.2e  vy:%10.2e %5.3fc" % (i, p1.vx, p1.vy, vc),
	print "x:%10.5f A" % (p1.x/Angstrom),
	# print " KE:%10.2e" % p1.avgKE
	print " KE:%6.2f%%" % (p1.avgKE*100/totalAvgKE)

    print
    print "Max Velociety: %5.3fc" % maxVc
    print

    ###########################################
    # Debug center of mass of pairs for
    # special e/p pair drift test
    ###########################################

    lastCm = None
    for i in range(len(world)-1):
        p1 = world[i]
	p2 = world[i+1]
	if isinstance(p2, Electron) and isinstance(p1, Proton):
	   cm = centerOfMass((p1, p2))
	   print "Center of Mass of pair %20.15f %20.15f %20.15f" % (cm[0]/Angstrom, cm[1]/Angstrom, cm[2]/Angstrom)
           if lastCm is not None:
                d = math.sqrt((cm[0] - lastCm[0]) ** 2 +
                (cm[1] - lastCm[1]) ** 2 +
                (cm[2] - lastCm[2]) ** 2)
                print "Distance is %20.15f" % (d/Angstrom)
                dd = d - lastD
                print "Change   is %20.15f" % (dd/Angstrom)
                move_dt = now - lastNow
                print "DT is %20.30f" % move_dt
                v = 0.0
                if move_dt != 0.0:
                    v = dd/move_dt ## Velocity 
                    print "M/S is ", dd/move_dt
                    a = (v - lastV) / move_dt
                    print "A is ", a
                    lastA += (a - lastA) * .001
                    print "avg A is", lastA
                lastV = v
                lastNow = now
                lastD = d
                gravityForce = 0.0
                gravityForce += p1.gravityForce(world[i-1])
                gravityForce += p1.gravityForce(world[i-2])
                gravityForce += p2.gravityForce(world[i-2])
                gravityForce += p2.gravityForce(world[i-1])
                print "Gravity Force is", gravityForce
                es = p1.esForce(p2)
                print "es from p1 to p2 is", es
                es = p1.esForce(world[i-2])
                print "es from p1 to e2 is", es
                print "es from 1 to p4 is", es
                print "Gravity A is", gravityForce/(p1.mass+p2.mass)
           lastCm = cm
    print

    #####################################################################
    # Calculate next postion now
    #####################################################################

    while True:  # DT restart loop

	# At this point, all paricles have a known positon and velocity
	# and the force is calculated to match the position.  Ending force
	# is also set to match the current force but will be updated.

	for it in range(3):
	    # print "begin itteration", it
	    for i in range(len(world)):
		p1 = world[i]
		p1.calculateEndVelocity(dt)
		p1.calculateEndPosition(dt)

	    # Update ending force based on ending position calcated above.
	    # Ending position is a function of ending force so whem we update
	    # the force, we can then loop back and calcate a new ending
	    # Position

	    # Could calcuate PE in same loop we use for updating forces
	    # because it duplicates a lot of the same work, but need to
	    # restructure code to do that.

	    for p1 in world:
		p1.zeroEndForce()
		for p2 in world:
		    p1.addEndForce(p2)

	    # totalKE2 = totalEndKeneticEnergy(world)
	    # totalPE2 = totalEndPotentialEnergy(world)
	    # curEnergy = totalKE2 + totalPE2
	    # error = (totalKE - totalKE2) + (totalPE - totalPE2)
	    # print "Energy error after itteration     %18.10e" % error

	if energyFix2:
	    # Ok, one last time, fudge velociety baesd on current position
	    # and total force for this position
	    # This is just always good I think.  Probably shouldn't be an option.
	    for i in range(len(world)):
		p1 = world[i]
		p1.calculateEndVelocity(dt)

	# Now calculate total Energy after that would result if we take this move

	totalKE2 = totalEndKeneticEnergy(world)
	totalPE2 = totalEndPotentialEnergy(world)

	#energyDiff = (totalKE2 + totalPE2) - (totalKE + totalPE) # last move error only

	# Ah, a computational problem showed up.  When one of the two is many
	# orders of magnatude different from the other, the accuracy is all lost
	# in the difference if do the above way vs the way below!

	energyDiff = (totalKE2 - totalKE) + (totalPE2 - totalPE) # last move error only
	energyDiffStart =  totalKE2 - startingTotalKE  # Error from start
	energyDiffStart += totalPE2 - startingTotalPE


	# print "old KE was", totalKE
	# print "old PE was", totalPE
	# print "new totalKE after move is", totalKE2
	# print "new totalPE after move is", totalPE2
	print "Energy error for move is %12.4e" % energyDiff,
	if energyDiffMax is not None:
	    print "max error %12.4e" % energyDiffMax,
	print
	# print "energy diff from start is", energyDiffStart

	cycleCount += 1

	# if False and cycleCount > 300:
	    # sys.exit(1)

	######################################################################
	# Dynamicly change dt to maintain error and maximise simulation speed
	######################################################################

	if dtAdjust and totalKE2 != 0.0:
	    # print "==DO DTADJUST cycleCount", cycleCount, "abs(energyDiff)", abs(energyDiff),
	    # print "totalKE2", totalKE2, "percent", abs(energyDiff) / totalKE2
	    if dt < dtMax and cycleCount > 3 and abs(energyDiff) / totalKE2 < 0.0001:
		# print "SPEEDUP -- increase DT abs(diff)/total is", abs(energyDiff) / totalKE2
		dt *= 2.0
		dt = min(dt, dtMax)
		# cycleCount = 0
		# continue
		# No need to restart -- take this move as fine but use a larger dt
		# for the next move

	    elif dt > dtMin and abs(energyDiff) / totalKE2 > 0.001:
		# print "SLOWDOWN -- redeuce DT abs(diff)/total is", abs(energyDiff) / totalKE2
		dt /= 2.0
		dt = max(dt, dtMin)
		for p1 in world:
		    p1.resetState()
		cycleCount = 0
		continue

	if energyDiffMax is None:
	    energyDiffMax = energyDiff
	energyDiffMax = max(energyDiffMax, abs(energyDiff))

	break # End of DT adjust loop

    #####################################################################
    # Make the move -- move current ending state to be the current
    # Also leves ending force set to same as starting force
    #####################################################################

    for p1 in world:
	p1.move()

    # print
    # print "MOVE MADE -------------------------------------------"

    now += dt

    ######################################################################
    # Fix total energy error
    # Adjust all velocities to remove energy error of energyDiffStart
    ######################################################################

    if energyFix:
	if energyDiffStart > totalKE2:
	    print "energy error greater than total KE error:", energyDiffStart, "total", totalKE2
	    energyDiffStart = totalKE2 * 0.5
	    # Only try to take half of total KE out of the system
	    # time.sleep(1)
	    # sys.exit(1)

	for i in range(len(world)):
	    # print
	    # print "Adjust KE for particle", i, "energyDiffStart error is", energyDiffStart
	    p1 = world[i]
	    ke = p1.keneticEnergy()
	    # print "Current ke is", ke
	    # print "percent of of total is", ke/totalKE2*100.0, "%"
	    # print "amount added of total energyDiffStart is", ke/totalKE2*energyDiffStart
	    newKe = ke - ke/totalKE2*energyDiffStart
	    # print "new should be", newKe
	    p1.setKeneticEnergy(newKe)
	    # print "new KE is now", p1.keneticEnergy()

	# totalKE3 = totalKeneticEnergy(world)
	# totalPE3 = totalPotentialEnergy(world)
	# energyDiff3 = (totalKE3 + totalPE3) - startingTotalE

	# print "--- after energy adjustments ----"
	# print "new totalKE after adjust is", totalKE3
	# print "new totalPE after adjust is", totalPE3
	# print "energy diff from start after adjust is", energyDiff3

pygame.quit()
sys.exit()

@


1.36
log
@old changes made years ago, just checking it in on the Mac to 
save it.
@
text
@d57 1
a58 1
screen_size = screen_width, screen_height = 1000, 800
d65 1
a66 1
pixelsPerAngstrom = 5.0
d1462 1
a1462 1
    def __init__(self, x=0.0, y=0.0, z=0.0):
d1464 2
a1465 2
	self.charge = +1.60218e-19 # in Coulombs
	self.mass = 1.672621898e-27
d1691 1
a1691 1
p1 =   Proton(Angstrom * 0.0, 0.0, 0.0 * Angstrom)
d1693 1
d1705 1
a1705 1
# Velcopety for the ep pair spaced at 0.25A
d1708 2
d1737 4
a1740 4
p2 = Proton(100.0 * Angstrom, 0.0 * Angstrom, 0.0 * Angstrom)
e2 = Electron(100.25 * Angstrom, 0.0 * Angstrom, 0.0 * Angstrom)
e2.vy = e1.vy # copy orbital velocity for second pair
p2.vy = p1.vy
d1744 1
a1744 1
#e2 = Electron(Angstrom * 1.5, Angstrom * 0.0, -0.5 * Angstrom)
d1760 2
a1761 2
    pi3 = ParticleImage(p2)
    piworld.append(pi3)
@


1.35
log
@checkpoint by ciall
@
text
@d38 1
a38 1
doMagnetic = True
d64 1
d66 1
a66 1
pixelsPerAngstrom = 10000.0
d193 1
a193 1
    # be the attraction between to such systems?
d199 7
d1667 14
d1693 1
d1707 1
a1707 1
e1.vy = p1.vy = 0.0
d1709 1
d1711 18
a1728 17
r = Angstrom * 0.25
print "r is", r
r = e1.x - p1.x
print "r is", r
rCenter = r * p1.mass / (p1.mass + e1.mass)
e1.vz = e1.c * math.sqrt(abs(1e-7 * e1.charge * p1.charge * rCenter/ (r * r * e1.mass)))
rCenter = r * e1.mass / (p1.mass + e1.mass)
p1.vz = -p1.c * math.sqrt(abs(1e-7 * e1.charge * p1.charge * rCenter/ (r * r * p1.mass)))
print "p1.vz is", p1.vz, "momentum is", p1.momentum()
print "e1.vz is", e1.vz, "momentum is", e1.momentum()
print "p1.vz - e1.vz", p1.vz - e1.vz

p1.vy = p1.vz
e1.vy = e1.vz
p1.vz = 0.0
e1.vz = 0.0
e1.vy /= 2.0
d1733 5
d1740 4
a1743 4
p2 =   Proton(Angstrom * 0.5, Angstrom * 0.0,  0.0 * Angstrom)
e2 = Electron(Angstrom * 1.5, Angstrom * 0.0, -0.5 * Angstrom)
e2.vy = 1600000.0
e2.vy = 800000.0
a1750 3
P1 = None
P2 = None
P3 = None
d1752 1
a1752 1
if False:
d1757 4
a1760 1
    P1 = p1
a1767 1
    P2 = p2
a1773 1
    P3 = p3
d1781 1
a1781 1
if True:
d1828 1
d1855 5
d1977 47
@


1.34
log
@checkpoint by ciall
@
text
@a61 1
pixelsPerAngstrom = 10000.0
d65 1
d234 1
a234 1
    p1.vx = c/2.0
d243 1
a243 1
    # p2.vx = -c/2.0
d792 2
a793 2
    def magneticForceTotal(self, p):
	return self.magneticForceTotal5(p)
d1107 1
a1107 1
	relativeV = self.subtract(self.V(), p.V())
d1109 1
a1109 1
	r3 = r2 ** (3.0/2.0)
d1111 2
a1112 2
	r = (p.x - self.x, p.y - self.y, p.z - self.z)
	rHat = self.product(-1.0/magnatude(r), r)
d1173 13
d1191 12
d1496 1
a1497 1
	eChange = 0.25
d1756 3
a1758 2
    p = 10
    e = 10
a1761 1
    percentOfScreen = 0.40
@


1.33
log
@checkpoint by ciall
@
text
@d54 1
a54 1
energyFix = True # fix based on total PE+KE at start -- doesn't work when magnatism added
a1113 2
	vHat = self.product(1.0/magnatude(relativeV), relativeV)

d1128 1
a1128 1
	if True:
d1139 5
a1143 1
	    df = -2.0 * self.ke * self.charge * p.charge * dr / r3
d1160 40
a1218 13

	if False:
	    print "ForceTotal5"
	    print " self.V() is ", self.V(), magnatude(self.V())
	    print " p.V() is    ", p.V(), magnatude(p.V())
	    print " relativeV is", relativeV, magnatude(relativeV)
	    print " r is        ", r
	    print " rhat is     ", rHat, magnatude(rHat)
	    es = self.esForce(p)
	    print " esForce is  ", es, magnatude(es)
	    print " F is        ", F, magnatude(F)
	    print

d1673 3
a1675 2
print "Now calcuate it as if p1 is standing still!"
e1.vz = e1.c * math.sqrt(abs(1e-7 * e1.charge * p1.charge * r/ (r * r * e1.mass)))
d1677 2
a1678 8
print "p1.vz is", p1.vz, "momentum is", p1.momentum()
print "e1.vz is", e1.vz, "momentum is", e1.momentum()
print "p1.vz - e1.vz", p1.vz - e1.vz
zeroMomentum([p1, e1])
print "after zeroMomentum()!"
print "p1.vz is", p1.vz, "momentum is", p1.momentum()
print "e1.vz is", e1.vz, "momentum is", e1.momentum()
print "p1.vz - e1.vz", p1.vz - e1.vz
d1700 1
a1700 1
if True:
d1728 1
a1728 1
if False:
d1731 2
a1732 2
    p = 2
    e = 1
@


1.32
log
@checkpoint by ciall
@
text
@d1119 7
a1125 5
	b = self.cross(relativeV, r)
	factor = 1e-7 * self.charge * p.charge * magnatude(relativeV) / r3
	if self.charge < 0:
	    factor *= -1.0 # well, needed to make ep pair push opposit directions!
	F = self.product(factor, b)
d1131 28
d1634 3
d1641 15
a1655 2
# print "p1.vy is", p1.vy, "momen is", p1.momentum()
# print "e1.vy is", e1.vy, "momen is", e1.momentum()
d1657 1
a1657 1
e1.vz = 1000000.0
@


1.31
log
@checkpoint by ciall
@
text
@d38 2
a39 2
doMagnetic = False
doMagneticInverse = True
d257 1
a257 1
    # zzzz
d292 1
a292 1
    # zzzz
d352 1
a352 1
    # zzz
d500 1
a500 1
    doMagnetic = False
d535 1
a535 1
	    f = p1.magneticForceTotal5(p2, dt=dt)
d546 1
a546 1
    # zzz
d1076 1
a1076 1
	# that's the same dimension as E is using. But istead
d1080 1
a1080 1
	# engy of a complex sprial or spinning orbit, or something
d1114 2
d1128 20
d1592 10
a1601 2
e1.vx = 800000.0
e1.vy = 800000.0
d1603 11
d1637 1
a1637 1
if True:
@


1.30
log
@checkpoint by ciall
@
text
@d65 1
a65 1
pixelsPerAngstrom = 100.0
d536 1
a536 1
	    print "%s%d.magneticForceTotal5(%s%d)" % (p1.symbol, i, p2.symbol, j),
d1564 1
a1564 1
e1 = Electron(Angstrom * 0.01, 0.0, 0.0 * Angstrom)
d1570 2
a1571 1
e1.vy = 8000000.0
d1589 1
a1589 1
if False:
d1596 1
a1596 1
if False:
d1599 1
a1599 1
    if True:
d1617 1
a1617 1
if True:
d1623 1
a1623 1
    monumtum = e1.mass * e1.c / 100.0
@


1.29
log
@checkpoint by ciall
@
text
@d38 1
a38 1
doMagnetic = True
d54 1
a54 1
energyFix = False # fix based on total PE+KE at start -- doesn't work when magnatism added
d65 1
a65 1
pixelsPerAngstrom = 10000.0
d1620 1
a1620 1
    e = 2
@


1.28
log
@checkpoint by ciall
@
text
@d38 1
a38 1
doMagnetic = False
d54 1
a54 1
energyFix = True # fix based on total PE+KE at start -- doesn't work when magnatism added
d232 1
a233 1
    p1 = Electron(0.0, 0.0, 0.0)
d242 1
a242 1
    p2 = Electron(10000000000.0*Angstrom, 1.0*Angstrom, 0.0)
d246 1
a246 1
    p2.vz = 6.0e8
d253 1
a253 1
    world.append(p3)
d535 2
a536 2
	    f = p1.magneticForceTotal4(p2, dt=dt)
	    print "%s%d.magneticForceTotal4(%s%d)" % (p1.symbol, i, p2.symbol, j),
d793 1
a793 1
	return self.magneticForceTotal4(p)
d928 1
a928 1
	# -- THIS IS BORKEN. Tried to do what I'm doing in Total4
d1067 73
d1588 1
a1588 1
if True:
d1622 1
a1622 1
    monumtum = e1.mass * e1.c / 1000.0
@


1.27
log
@checkpoint by ciall
@
text
@d38 1
a38 1
doMagnetic = True
a45 1
dtMin = 1e-18
a47 2
dtMax = 1e-20
dtMax = 1e-18
d54 2
a55 1
energyFix = True
d65 1
a65 1
pixelsPerAngstrom = 100.0
d232 1
a233 1
    p1 = Proton(0.0, 0.0, 0.0)
d235 1
a235 1
    p1.vy = c/2.0
d242 1
a242 1
    p2 = Electron(1.0*Angstrom, 0.0*Angstrom, 0.0)
d246 1
a246 1
    # p2.vz = 6.0e8
d253 1
a253 1
    # world.append(p3)
d295 1
a295 1
    if True:
d1035 4
a1038 4
	dr = self.dot(relativeV, rHat)
	df = -2.0 * self.ke * self.charge * p.charge * dr / r3
	magFactor = 1.0/(self.c*self.c)
	F = self.product(df*magFactor, rHat)
d1092 7
a1098 14
	# f=ma
	# a = f / m = self.fx / self.mass
	# v2 = v1 + a * dt # assumes constant acceleration
	if True:
	    # new way
	    # Assume linear change in acceleration from start (fx to end endFx)
	    self.endVx = self.vx + ((self.fx + self.endFx) / 2.0) * dt / self.mass
	    self.endVy = self.vy + ((self.fy + self.endFy) / 2.0) * dt / self.mass
	    self.endVz = self.vz + ((self.fz + self.endFz) / 2.0) * dt / self.mass
	else:
	    # Old way -- assume constant acceleration
	    self.endVx = self.vx + self.fx * dt / self.mass
	    self.endVy = self.vy + self.fy * dt / self.mass
	    self.endVz = self.vz + self.fz * dt / self.mass
a1101 6
	# Assume constant acceleration -- so average of start
	# and end velocity is what is used to calculate new position

    	## self.endX = self.x + (self.vx + self.endVx) * dt / 2.0
    	## self.endY = self.y + (self.vy + self.endVy) * dt / 2.0
    	## self.endZ = self.z + (self.vz + self.endVz) * dt / 2.0
a1113 1

d1491 1
a1491 1
e1 = Electron(Angstrom * 1.0, 0.0, 0.001 * Angstrom)
a1493 1
e1.vy = 1200000.0
d1496 2
d1515 1
a1515 1
if False:
d1740 1
a1740 1
	# and the force is calcuated to match the position.  Ending force
d1770 7
d1792 1
a1792 3
	if energyDiffMax is None:
	    energyDiffMax = energyDiff
	energyDiffMax = max(energyDiffMax, abs(energyDiff))
d1799 3
a1801 1
	print "max error %12.4e" % energyDiffMax
d1833 4
@


1.26
log
@checkpoint by ciall
@
text
@d38 1
a38 1
doMagnetic = False
d310 10
a319 12
	for i in range(len(world)):
	    p = world[i]

	for i in range(len(world)):
	    p1 = world[i]
	    p1.calculateEndVelocity(dt)
	    p1.calculateEndPosition(dt)

	for p1 in world:
	    p1.zeroEndForce()
	    for p2 in world:
		p1.addEndForce(p2)
d537 2
a538 2
	    f = p1.magneticForceTotal3(p2, dt=dt)
	    print "%s%d.magneticForceTotal3(%s%d)" % (p1.symbol, i, p2.symbol, j),
d657 1
d795 1
a795 1
	return self.magneticForceTotal3(p)
d930 8
a937 10
	# Calculate De/dt and make magenetic force
	# Nothing more than an increase in the ES force based
	# on De/dt.
	# This is a very different approach, but yet seems to produces
	# the same sort of results for current -- aka the
	# sum of many electons moving at once.  But it has
	# the intersting effect of having no magnetic force
	# at all when the two particles pass side by side
	# becuase de/dt = 0 at that point!  Which might be
	# of key importance in orbits!
d949 2
a950 1
	relativeV = self.subtract(self.V(), p.V())
d955 3
a957 1
	rHat = self.product(1.0/magnatude(r), r)
d965 2
a966 1
	df = self.product(-2.0 * self.ke * self.charge * p.charge / r3, dr)
d995 74
d1498 1
a1498 1
magneticTest()
d1563 2
a1564 3
    speed = 10000000.0
    speed = 10.0
    speed = 2.0
d1566 1
a1566 1
    percentOfScreen = 0.10
d1577 3
a1579 3
	p.vx = random.random() * speed
	p.vy = random.random() * speed
	p.vz = random.random() * speed
d1588 3
a1590 3
	p.vx = random.random() * speed
	p.vy = random.random() * speed
	p.vz = random.random() * speed
d1629 2
d1737 3
a1739 1
	print "%d vx:%10.2e  vy:%10.2e " % (i, p1.vx, p1.vy),
d1744 2
@


1.25
log
@checkpoint by ciall
@
text
@d38 1
a38 1
doMagnetic = True
d245 1
a245 1
    p2.vx = -c/2.0
d255 1
a255 1
    world.append(p3)
d296 57
d354 4
d503 1
a503 1
def magneticTest2(world):
d539 2
a540 2
	    f = p1.magneticForceTotal2(p2)
	    print "%s%d.magneticForceTotal2(%s%d)" % (p1.symbol, i, p2.symbol, j),
d606 1
a606 1
    def X(self):
d657 23
d695 11
d796 1
a796 1
	return self.magneticForceTotal2(p)
d928 66
d1423 1
a1423 1
# magneticTest()
@


1.24
log
@checkpoint by ciall
@
text
@d1 1
a1 1
#!/usr/bin/python
d479 1
a479 1
	    print "%s%d.magneticForceTotal(%s%d)" % (p1.symbol, i, p2.symbol, j),
d701 2
d731 33
d780 50
a829 6
	# r points from self to p 
	r = (p.x - self.x, p.y - self.y, p.z - self.z)
	if doMagneticInverse:
	    r = self.product(-1.0, r)
	f = self.cross(self.V(), self.cross(p.V(), r))
	F = self.product(1e-7 * self.charge * p.charge  / r3, f)
d1262 1
a1262 1
magneticTest()
@


1.23
log
@checkpoint by ciall
@
text
@d129 1
a129 2
    # For x,y 1.0 0.0 total mag field is 4.18946069487e+22  ShOuld be infinity on wire I think maybe?

d232 2
d241 2
d245 1
a245 1
    # p2.vx = -c/2.0
d249 7
d259 1
d261 1
a261 1
    if True:
d278 1
a278 1
    if True:
d296 5
a300 1
    magneticTest2(p1, p2)
d302 1
a302 1
    #sys.exit(1)
d308 1
a308 1
    if True:
d435 1
a435 1
    magneticTest2(p1, p2)
d442 8
a449 3
def magneticTest2(p1, p2):
    p1.zeroForce()
    p1.addForce(p2)
d453 18
a470 7
    print "p1 %s X,Y %.1f, %.1f" % (p1.symbol, p1.x/Angstrom, p1.y/Angstrom)
    print "p2 %s X,Y %.1f, %.1f" % (p2.symbol, p2.x/Angstrom, p2.y/Angstrom)
    print
    print "V of p1", p1.V(), "%5.3fc %s" % (magnatude(p1.V())/c, p1.symbol)
    print "V of p2", p2.V(), "%5.3fc %s" % (magnatude(p2.V())/c, p2.symbol)
    diffV = p1.subtract(p1.V(), p2.V())
    print "diffV of p1-p2", diffV, "%5.3fc" % (magnatude(diffV)/c)
d472 10
a481 2
    p1p2 = p1.magneticForce(p2)
    p2p1 = p2.magneticForce(p1)
d483 1
a483 2
    p1p22 = p1.magneticForce2(p2)
    p2p12 = p2.magneticForce2(p1)
d486 1
a486 23
    print "ES  Force on p1 by p2", p1.F()
    print
    print "Mag Field B on p1 created by p2 field", p1.magneticField(p2)
    print "Mag Field B on p2 created by p1 field", p2.magneticField(p1)
    print
    # print "Mag Force   on p1 created by p2 field", p1p2
    # print "Mag Force   on p2 created by p1 field", p2p1
    # print
    print "Mag Force2  on p1 created by p2 field", p1p22
    print "Mag Force2  on p2 created by p1 field", p2p12
    print
    # print "Total on p1", p1.add(p1p2, p1.product(-1.0, p2p1))
    # print "Total on p2", p1.add(p2p1, p1.product(-1.0, p1p2))
    # print
    print "Total2 on p1             ", p1.add(p1p22, p1.product(-1.0, p2p12)),
    print magnatude(p1.add(p1p22, p1.product(-1.0, p2p12)))
    print "Total2 on p2             ", p1.add(p2p12, p1.product(-1.0, p1p22)),
    print magnatude(p1.add(p2p12, p1.product(-1.0, p1p22)))
    print
    print "p1.magneticForceTotal(p2)", p1.magneticForceTotal(p2),
    print magnatude(p1.magneticForceTotal(p2))
    print "p2.magneticForceTotal(p1)", p2.magneticForceTotal(p1),
    print magnatude(p2.magneticForceTotal(p1))
d488 2
d727 27
d1064 1
a1064 1
	    zeroMonumtum() # fix montum
d1146 35
d1183 1
a1183 1
# magneticTest()
a1285 1

d1289 2
a1290 38
#####################################################################
# Normalize monumtum
#####################################################################

def zeroMonumtum():
    ### Normalize monuntum to zero to freeze frame of referece
    tm = totalMomentum(world)
    n = len(world)
    totalMass = 0.0
    for i in range(n):
	totalMass += world[i].mass
    fudge = (-tm[0]/totalMass, -tm[1]/totalMass, -tm[2]/totalMass)
    for i in range(n):
	world[i].addVelocity(fudge)

zeroMonumtum()

#####################################################################
### Move objects to place center of mass in the middle of the screen
#####################################################################

def centerMass():
    centerX = (screen_width / pixelsPerAngstrom * Angstrom) / 2.0
    centerY = (screen_height / pixelsPerAngstrom * Angstrom) / 2.0
    centerZ = (screen_depth / pixelsPerAngstrom * Angstrom) / 2.0
    cx = cy = cz = 0.0
    tm = 0.0
    for p in world:
    	cx += p.x * p.mass
    	cy += p.y * p.mass
    	cz += p.z * p.mass
	tm += p.mass
    for p in world:
    	p.x = p.x - cx / tm + centerX
    	p.y = p.y - cy / tm + centerY
    	p.z = p.z - cz / tm + centerZ

centerMass()
@


1.22
log
@checkpoint by ciall
@
text
@d4 1
a4 1
    physics.py - Atomic particle simuilation experments
d37 1
d41 140
d683 1
a683 1
	# Total froce on self, caused by relative self and p velociety
a941 8
screen_size = screen_width, screen_height = 600, 400
screen_size = screen_width, screen_height = 1000, 800
screen_depth = 1000 # z dimension
pixelsPerAngstrom = 4000.0
pixelsPerAngstrom = 10000.0
pixelsPerAngstrom = 100.0
pixelsPerAngstrom = 0.00001
pixelsPerAngstrom = 100000000.0
d966 1
a966 1
	size = int(size)
d973 1
a974 1
	eChange = 1.00
d1104 2
a1205 16
dt = 2e-17
dt = 2e-18
dt = 2e-19

dtMin = 1e-20
dtMin = 1e-18
dtMin = 1e-30

dtMax = 1e-18
dtMax = 1e-10
dtMax = 1e-1

dt = dtMin
dtAdjust = True

energyFix = True
d1313 3
a1315 1
    print "doMagnetic", doMagnetic, "doMagenetiInverse", doMagneticInverse
d1327 2
d1332 2
a1333 1
    print "Relative e:  %8.1e" % ((totalKE - startingTotalKE) + (totalPE - startingTotalPE))
d1337 2
a1338 1
    print "PixelsPerAngstrom", pixelsPerAngstrom
d1531 1
@


1.21
log
@checkpoint by ciall
@
text
@d806 1
d808 1
a808 2
pixelsPerAngstrom = 100000.0
pixelsPerAngstrom = 100.0
d1031 2
a1032 2
    p = 6
    e = 1
@


1.20
log
@checkpoint by ciall
@
text
@d33 2
a34 1
BounceCount = 0
d844 1
a844 1
	global BounceCount
d850 1
a850 1
	    BounceCount += 1
d856 1
a856 1
	    BounceCount += 1
d862 1
a862 1
	    BounceCount += 1
d868 1
a868 1
	    BounceCount += 1
d874 1
a874 1
	    BounceCount += 1
d880 11
a890 1
	    BounceCount += 1
d896 1
a896 1
	# We adjust the systems totale target for fixing energy
d1031 2
a1032 2
    p = 5
    e = 5
d1095 1
a1095 1
if True:
d1106 2
d1112 1
a1112 1
if True:
d1128 2
d1216 1
a1216 1
    print "Inside Rlimit ", InsideRLimitCount, "Bounce:", BounceCount
@


1.19
log
@checkpoint by ciall
@
text
@d36 2
d89 2
d93 3
a95 2
    # p1.vx = 2.0e8
    # p1.vy = 1.0e8
d99 3
a101 4
    p2 = Proton(10000000000000.0*Angstrom, 0.0, 0.0)
    p2 = Proton(10.0*Angstrom, 0.0, 0.0)
    # p2.vx = -2.0e8
    # p2.vy = -1.0e8
a104 1
    c = 299792458.0 # Speed of light m/s
d125 6
a130 6
	if True:
	    # Make the magnatude of the difference equal to c
	    rV = p1.subtract(p1.V(), p2.V())
	    s = magnatude(rV)
	    p1.vx,p1.vy,p1.vz = p1.product(c/s, p1.V())
	    p2.vx,p2.vy,p2.vz = p2.product(c/s, p2.V())
d145 1
d147 5
a277 3



d291 5
a295 2
    print "V of p1", p1.V(), "%5.3fc" % (magnatude(p1.V())/c)
    print "V of p2", p2.V(), "%5.3fc" % (magnatude(p2.V())/c)
d305 2
a306 1
    print "ES  Force between p1 p2", p1.F()
d320 1
a320 1
    print "Total2 on p1", p1.add(p1p22, p1.product(-1.0, p2p12)),
d322 1
a322 1
    print "Total2 on p2", p1.add(p2p12, p1.product(-1.0, p1p22)),
d325 4
d374 1
d376 2
d381 1
d426 6
d436 1
d477 2
d481 16
d520 1
a520 1
	# as our speed moving THOUGH the mag field.
d540 27
d585 6
d783 1
d793 1
d807 1
a807 1
pixelsPerAngstrom = 10.0
d959 1
a959 1
magneticTest()
d989 1
a989 1
if True:
d996 1
a996 1
if True:
d1017 1
a1017 1
if False:
d1026 1
a1026 1
    percentOfScreen = 0.90
d1179 1
d1237 1
a1237 4
	if isinstance(p1, Electron):
	    sys.stdout.write('e')
	else:
	    sys.stdout.write('p')
@


1.18
log
@checkpoint by ciall
@
text
@d90 3
a92 2
    p1.vy = 1.0e8
    # p1.vz = 6.0e8
d94 3
a96 2
    p2 = Proton(1.0*Angstrom, 0.0, 0.0)
    p2.vx = -2.0e8
d101 179
a281 1
    # zzzz
d283 6
a288 2
    print "V of p1", p1.V()
    print "V of p2", p2.V()
d293 3
d301 5
a305 2
    print "Mag Force   on p1 created by p2 field", p1p2
    print "Mag Force   on p2 created by p1 field", p2p1
d307 7
a313 3
    print "Total on p1", p1.sum(p1p2, p1.product(-1.0, p2p1))
    print "Total on p2", p1.sum(p2p1, p1.product(-1.0, p1p2))

a316 4
    sys.exit(1)

	

d430 1
a430 1
    def sum(self, v1, v2):
d433 3
d452 1
a452 1
	B = self.product(1e-7 * p.charge, self.cross(p.V(), rHat))
d471 23
@


1.17
log
@checkpoint
@
text
@d49 8
d83 18
d103 16
d120 2
d167 3
d177 9
d228 53
d664 2
a665 1
neutronGravityTest()
@


1.16
log
@checkpoint
@
text
@d47 34
d166 6
d311 1
a311 1
    	# Limit distance to 2 A to solve computational problems.
d555 1
@


1.15
log
@checkpoint
@
text
@d93 2
a361 1
pixelsPerAngstrom = 20.0
d364 1
d521 1
a521 1
e1 = Electron(Angstrom * 0.001, 0.0, 0.0 * Angstrom)
a526 8
e1 = Electron(Angstrom * 0.002, 0.0, 0.0 * Angstrom)
e1.vy = 37000000.0
e1.vy = 50000000.0 / math.sqrt(2.0)
e1 = Electron(Angstrom * 0.001, 0.0, 0.0 * Angstrom)
e1.vy = 50000000.0
e1.vy = 100000000.0
e1.vy = 71170908.9604/2.0
e1.vy = 71420000.0
d529 2
a530 2
p2 =   Proton(Angstrom * 0.05, Angstrom * 0.0,  0.0 * Angstrom)
e2 = Electron(Angstrom * 7.0, Angstrom * 0.0, -1.0 * Angstrom)
d534 3
a536 2
p3 =   Proton(Angstrom * 10.0, Angstrom * 0.0, 0.0)
e3 = Electron(Angstrom * 11.0, Angstrom * 0.0, 0.0)
a537 1
e3.vy = 800000.0
d544 1
a544 1
if False:
d551 1
a551 1
if False:
d554 1
a554 1
    if False:
d572 1
a572 1
if True:
d575 2
a576 2
    p = 20
    e = 20
d783 6
d796 3
a798 1
	print "x:%10.5f Angstroms" % (p1.x/Angstrom)
@


1.14
log
@checkpoint
@
text
@a151 1
	# zzz
a318 1
	# zzz
d519 1
a519 1
e1 = Electron(Angstrom * 0.024, 0.0, 0.0 * Angstrom)
d525 9
a533 2
e1.vy = 6000000.0
e1.vx = e1.vy
d581 2
a582 2
    p = 10
    e = 10
d585 1
d587 3
a589 2
    xwidth = (screen_width * .5 / pixelsPerAngstrom) * Angstrom
    ywidth = (screen_height * .5 / pixelsPerAngstrom) * Angstrom
@


1.13
log
@checkpoint
@
text
@d35 2
d90 2
d342 3
a349 1
	self.mass = 2 * 9.10938356e-31 # twice the electron for testing
d351 5
a355 1

d374 5
d381 1
a381 1
	    size = 4
d384 1
a384 1
	    size = 6
d386 4
a389 3
	if zMax > zMin:
	    size *= ((self.p.z - zMin) * 1.0 / (zMax - zMin)) + 0.5
	    size = int(size) + 1
a390 3
	x = self.spaceToPixels(self.p.x)
	y = self.spaceToPixels(self.p.y)
	z = self.spaceToPixels(self.p.z)
d576 4
a579 2
    p = 2
    e = 2
d591 3
a593 3
	p.vx = random.random() * 100.0
	p.vy = random.random() * 100.0
	p.vz = random.random() * 100.0
d602 3
a604 3
	p.vx = random.random() * 100.0
	p.vy = random.random() * 100.0
	p.vz = random.random() * 100.0
@


1.12
log
@checkpoint
@
text
@d17 1
d30 4
d307 3
d343 1
a344 1
	self.mass = 2 * 9.10938356e-31 # twice the electron for testing
d349 9
a357 2
global Bounce
Bounce = False
d363 1
a363 1
    def display(self):
d366 1
a366 1
	    size = 2
d369 11
a379 4
	    size = 5
	x = int(20.0 * self.p.x / Angstrom)
	y = int(20.0 * self.p.y / Angstrom)
	inset = 5
d381 2
a382 2
	    inset = 20
	vChange = -1.0
d385 3
a387 1
	global Bounce
d389 1
a389 1
	    self.p.vx *= vChange
d391 3
a393 2
	    Bounce = True
	    self.p.x = inset * Angstrom / 20.0
d395 1
a395 1
	    self.p.vx *= vChange
d397 3
a399 2
	    Bounce = True
	    self.p.x = (screen_width - inset) * Angstrom / 20.0
d401 1
a401 1
	    self.p.vy *= vChange
d403 3
a405 2
	    Bounce = True
	    self.p.y = inset * Angstrom / 20.0
d407 13
a419 1
	    self.p.vy *= vChange
d421 21
a441 4
	    Bounce = True
	    self.p.y = (screen_height - inset) * Angstrom / 20.0
	x = int(20.0 * self.p.x / Angstrom)
	y = int(20.0 * self.p.y / Angstrom)
d444 8
d507 2
a508 2
p1 =   Proton(Angstrom * 0.0, 0.0, 0.1 * Angstrom)
e1 = Electron(Angstrom * 3.0, 0.0, 0.2 * Angstrom)
d514 2
a515 1
e1.vy = 200000.0
d517 2
a518 2
p2 =   Proton(Angstrom * 7.0, Angstrom * 0.0,  1.0 * Angstrom)
e2 = Electron(Angstrom * 8.0, Angstrom * 0.0, -1.0 * Angstrom)
a526 10
if False: # Hydrogen
    p1 =   Proton(Angstrom * 0.0, 0.0, 0.0)
    e1 = Electron(Angstrom * 1.0, 0.0, 0.0)
    e1.vy = 1600000.0

    p2 =   Proton(Angstrom * 2.0, Angstrom * 0.0, 0.0)
    e2 = Electron(Angstrom * 8.0, Angstrom * 0.0, 0.0)
    e2.vy = 800000.0


d563 2
a564 2
    p = 5
    e = 5
d566 2
d570 4
a573 4
	x = random.random() * 10 * Angstrom
	y = random.random() * 10 * Angstrom
	#z = random.random() * 10 * Angstrom
	z = 0.0
d578 1
a578 1
	#p.vz = random.random() * 100.0
d581 4
a584 4
	x = random.random() * 10 * Angstrom
	y = random.random() * 10 * Angstrom
	#z = random.random() * 10 * Angstrom
	z = 0.0
d589 1
a589 1
	#p.vz = random.random() * 100.0
d609 1
d639 3
a641 2
    centerX = (screen_width / 20.0 * Angstrom) / 2.0
    centerY = (screen_height / 20.0 * Angstrom) / 2.0
d652 1
a652 1
    	p.z = p.z - cz / tm
d686 2
d689 17
a705 5
	if isinstance(p.p, Proton):
	    p.display()
    for p in piworld:
	if isinstance(p.p, Electron):
	    p.display()
d722 1
a722 2
    global Bounce
    if Bounce:
d727 1
a727 1
	Bounce = False
d736 5
d745 16
a760 6
    if P1 is not None and P2 is not None:
	print "Distance between P1 P2 %11.6f" % (P1.distance(P2)[0]/Angstrom)
    if P2 is not None and P3 is not None:
	print "Distance between P2 P3 %11.6f" % (P2.distance(P3)[0]/Angstrom)
    if P1 is not None and P3 is not None:
	print "Distance between P1 P3 %11.6f" % (P1.distance(P3)[0]/Angstrom)
@


1.11
log
@checkpoint
@
text
@d27 1
a27 1
RLimit = 0.1 * Angstrom		# Radius limit hack
d335 1
a336 1
	self.mass = 1.672621898e-27
d340 1
d355 5
a359 2
	x = int(200 + 20.0 * self.p.x / Angstrom)
	y = int(200 + 20.0 * self.p.y / Angstrom)
d361 1
a362 1
	eChange = 0.25
d364 1
a364 1
	if x < 0 and self.p.vx < 0:
d368 2
a369 5
	    # print "update self.p.x from", self.p.x,
	    self.p.x = (1 - 200.0) * Angstrom / 20.0
	    # print "to", self.p.x
	    x = int(200 + 20.0 * self.p.x / Angstrom)
	if x > screen_width and self.p.vx > 0:
d373 2
a374 5
	    # print "update self.p.x from", self.p.x,
	    self.p.x = (screen_width - 1.0 - 200.0) * Angstrom / 20.0
	    # print "to", self.p.x
	    x = int(200 + 20.0 * self.p.x / Angstrom)
	if y < 0 and self.p.vy < 0:
d378 2
a379 3
	    self.p.y = (1.0 - 200.0) * Angstrom / 20.0
	    y = int(200 + 20.0 * self.p.y / Angstrom)
	if y > screen_height and self.p.vy > 0:
d383 3
a385 2
	    self.p.y = (screen_height - 1.0 - 200.0) * Angstrom / 20.0
	    y = int(200 + 20.0 * self.p.y / Angstrom)
d477 1
a477 1
if True:
d484 1
a484 1
if True:
d505 33
a573 1
	# fudge = (-tm[0]/n, -tm[1]/n, -tm[2]/n)
d580 14
a593 1
## TBD
@


1.10
log
@checkpoint
@
text
@d27 15
d104 1
a104 1
	d2 = dx ** 2.0 + dy ** 2.0 + dz ** 2.0
d106 1
a106 1
	if d2 == 0.0:
d109 1
a109 1
	force = self.ke * (self.charge * p.charge) / d2
d111 1
a111 1
	d = math.sqrt(d2)
d113 3
a115 3
	self.fx += force * dx / d
	self.fy += force * dy / d
	self.fz += force * dz / d
d129 1
a129 1
	d2 = dx ** 2.0 + dy ** 2.0 + dz ** 2.0
d131 1
a131 1
	force = self.ke * (self.charge * p.charge) / d2
d133 1
a133 1
	d = math.sqrt(d2)
d135 3
a137 3
	self.endFx += force * dx / d
	self.endFy += force * dy / d
	self.endFz += force * dz / d
d242 3
a244 1
	return dx ** 2.0 + dy ** 2.0 + dz ** 2.0
d255 10
a264 1
	return dx ** 2.0 + dy ** 2.0 + dz ** 2.0
d267 2
a268 1
	return math.sqrt(self.distance2(p))
d271 2
a272 1
	return math.sqrt(self.endDistance2(p))
d280 1
a280 4
	d = self.distance(p)

	if d == 0:
	    return 0.0	# Bogus should be +infinity
d282 1
a282 1
	return self.ke * self.charge * p.charge / d
d290 3
a292 1
	d = self.endDistance(p)
d294 15
a308 2
	if d == 0:
	    return 0.0	# Bogus should be +infinity
a309 1
	return self.ke * self.charge * p.charge / d
d439 2
d445 2
a446 5
p1 = Electron(Angstrom * 0.0, 0.0, 0.0)
p1 =   Proton(Angstrom * 0.0, 0.0, 0.0)
e1 =   Proton(Angstrom * 1.0, 0.0, 0.0)
e1 = Electron(Angstrom * 1.0, 0.0, 0.0)
e1 = Electron(Angstrom * 6.0, 0.0, 0.0)
d449 2
a451 1
e1.vy = 1200000.0
a452 1
e1.vy = 0.0
d454 2
a455 6
p2 =   Proton(Angstrom * 2.0, Angstrom * 0.0, 0.0)
e2 = Electron(Angstrom * 3.0, Angstrom * 0.0, 0.0)
p2 =   Proton(Angstrom * 5.0, Angstrom * 2.0, 0.0)
e2 = Electron(Angstrom * 6.0, Angstrom * 2.0, 0.0)
p2 =   Proton(Angstrom * 5.0, Angstrom * 0.0, 0.0)
e2 = Electron(Angstrom * 6.0, Angstrom * 0.0, 0.0)
d486 1
a486 1
if False:
d489 1
a489 1
    if True:
a514 1
dtMin = 1e-30
d517 1
d519 1
a520 1
dtMax = 2e-17
d525 1
a525 1
energyFix = False
d626 1
a626 1
	print "Distance between P1 P2 %11.6f" % (P1.distance(P2)/Angstrom)
d628 1
a628 1
	print "Distance between P2 P3 %11.6f" % (P2.distance(P3)/Angstrom)
d630 1
a630 1
	print "Distance between P1 P3 %11.6f" % (P1.distance(P3)/Angstrom)
@


1.9
log
@checkpoint
@
text
@d27 29
d91 3
d162 1
a162 1
    def move(self, dt):
d165 1
a165 3
	self.oldX = self.x
	self.oldY = self.y
	self.oldZ = self.z
a170 4
	self.oldVx = self.vx
	self.oldVy = self.vy
	self.oldVz = self.vz

a174 4
	self.oldFx = self.fx
	self.oldFy = self.fy
	self.oldFz = self.fz

d179 8
a186 7
    def resetPositionAndVelocity(self): # Go back to last step
	self.x = self.oldX
	self.y = self.oldY
	self.z = self.oldZ
	self.vx = self.oldVx
	self.vy = self.oldVy
	self.vz = self.oldVz
d189 2
a190 2
    	## 1/2 m v**2
    	return 0.5 * self.mass * (self.vx ** 2.0 + self.vy ** 2.0 + self.vz ** 2.0)
d193 4
d198 4
a201 1
	return 0.5 * self.mass * (self.endVx ** 2.0 + self.endVy ** 2.0 + self.endVz ** 2.0)
d250 6
a255 1
	    return 0.0	# should be +infinity
d257 1
a257 1
	return self.ke * self.charge * p.charge / self.distance(p)
d263 6
a268 1
	    return 0.0	# should be +infinity
d270 1
a270 1
	return self.ke * self.charge * p.charge / self.endDistance(p)
a298 243
def test1():
    ## Want to test a 1D line of electrons that all interact with each other to see how
    ## Fast kentic energy moves through them.  Hopeing to find an indication that the speed 
    ## of light comes not from the field strength but from the time it takes for kenetic
    ## energy to move through the line of electrons. 

    ## The idea is to model an electron as a body-less point field source that has a location
    ## in space and a mass but no size.  The mass only controls how fast it's velocity changes
    ## in response to the sum of all the forces.

    print "running test"

    world = []

    for i in range(5):
	x = i * 0.000000001
    	world.append(Electron(x, 0.0, 0.0))

    # Run simulation!

    now = 0.0
    dt = 1e-20
    dt = 1e-18
    dt = 2e-18
    t1 = None
    t2 = None
    xMin = None
    xMax = None

    while True:
    	now += dt

    	print "now is", now,

	for i in range(len(world)):
	    e1 = world[i]
	    # print i, e1.x, e1.y, e1.z
	    print "%e" % e1.x,
	print

	x = world[1].x

	if xMin is None and xMax is None:
	    xMin = x	# look for xMin now
	    t1 = now

	if xMin is not None:
	    if x <= xMin:
		xMin = x
		t1 = now
	    else:
	    	# Found min, look for max now!
		xMax = x
		t2 = now
		xMin = None

	if xMax is not None:
	    if x >= xMax:
		xMax = x
		t2 = now
	    else:
	    	# Found max look for min again
		xMin = x
		xMax = None
		print "t1 is ", t1, "t2 is", t2, "diff is", t2-t1,
		if t2-t1 > 0.0:
		    print "freq is", 1.0 / (2.0*(t2-t1)),
		print
		time.sleep(1)
		

	# Update forces all the electrons place on each other according
	# to their current positions.

	for i in range(len(world)):
	    if i == 0 or i == len(world) - 1:
		continue # don't move first or last
	    e1 = world[i]
	    force = 0.0
	    e1.zeroForce()
	    for e2 in world:
	    	e1.addForce(e2)

	# Update velocity of all the electrons according to the forces applied
	# And update position with new velocity

	for i in range(len(world)):
	    if i == 0 or i == len(world) - 1:
		continue # don't move first or last
	    e1 = world[i]
	    e1.updateVelocity(dt)
	    e1.updatePosition(dt)

def test2():
    ## test an electon and proton alone.  
    ## what freq does it oscillate at?

    print "running test"

    world = []

    spacing = 0.0000000001 # One Angstrom 10e-10 meters

    world.append(  Proton(spacing * 0.0, 0.0, 0.0))
    world.append(Electron(spacing * 1.0, 0.0, 0.0))

    # world.append(  Proton(spacing * 3.0, 0.0, 0.0))
    # world.append(Electron(spacing * 4.0, 0.0, 0.0))
    # e2 = world[3]
    # e2.vy = 1600000.0

    p = world[0]
    e = world[1]
    e.vy = 1000000.0
    e.vy = 2000000.0
    e.vy = 1500000.0
    e.vy = 1600000.0
    e.vy = 0.0
    # zzz

    # Run simulation!

    now = 0.0
    dt = 1e-20
    dt = 1e-21
    dt = 1e-22
    t1 = None
    t2 = None
    xMin = None
    xMax = None
    lastKE = 0.0
    lastPE = 0.0

    while True:
    	now += dt

	#########################################################################################
	### Calculate energy
	#########################################################################################

    	print "Time now is %8.4e" % now,

	totalKE = 0.0
	totalPE = 0.0

	for i in range(len(world)):
	    p1 = world[i]
	    ke = p1.keneticEnergy() 
	    print "ke%d=%.3e" % (i, ke),
	    # print "vx%d=%.3e" % (i, p1.vx),
	    totalKE += ke
	    for j in range(i, len(world)):
		p2 = world[j]
		if p1 is p2:
		    continue
		pe = p1.potentialEnergy(p2)
		print "pe%d-%d=%.3e" % (i, j, pe),
		totalPE += pe
	print
	print "Total ke", totalKE, "change from last", totalKE - lastKE
	print "Total pe", totalPE, "change from last", totalPE - lastPE
	print "Total e: %8.1e" % (totalKE + totalPE), "change from last", (totalKE - lastKE) + (totalPE - lastPE)
	print

	lastKE = totalKE
	lastPE = totalPE

	#########################################################################################
	### END Calculate energy
	#########################################################################################

    	print "Time now is %8.4e" % now,

	for i in range(len(world)):
	    e1 = world[i]
	    # print i, e1.x, e1.y, e1.z
	    print "%10.4f" % (e1.x / spacing),
	print

	if world[1].x/spacing < -0.01:
	    break

	x = world[1].x

	if xMin is None and xMax is None:
	    xMin = x	# look for xMin now
	    t1 = now

	if xMin is not None:
	    if x <= xMin:
		xMin = x
		t1 = now
	    else:
	    	# Found min, look for max now!
		xMax = x
		t2 = now
		xMin = None
		print "X min found at", x/spacing
		time.sleep(1)

	if xMax is not None:
	    if x >= xMax:
		xMax = x
		t2 = now
	    else:
	    	# Found max look for min again
		xMin = x
		xMax = None
		print "t1 is ", t1, "t2 is", t2, "diff is", t2-t1,
		if t2-t1 > 0.0:
		    print "freq is", 1.0 / (2.0*(t2-t1)),
		print
		# sys.exit()
		time.sleep(3)
		

	# Update forces all the particles place on each other according
	# to their current positions.

	for i in range(len(world)):
	    # if i == 0 or i == len(world) - 1:
		# continue # don't move first or last
	    p1 = world[i]
	    force = 0.0
	    p1.zeroForce()
	    for p2 in world:
	    	p1.addForce(p2)
	    # print "p1 force is", p1.fx

	# Update velocity of all the particles according to the forces applied
	# And update position with new velocity

	for i in range(len(world)):
	    # if i == 0 or i == len(world) - 1:
		# continue # don't move first or last
	    p1 = world[i]
	    p1.updateVelocity(dt)
	    p1.updatePosition(dt)
	    # print "p1 velocity x,y is", p1.vx, p1.vy


# test1()
# test2()
d320 1
d325 4
d333 4
d341 2
d347 3
a399 1

a406 1
e1 = Electron(Angstrom * 3.0, 0.0, 0.0)
d408 1
a409 2
e1.vy = 0.0
e1.vy = 400000.0
d413 2
d452 1
a452 1
if True:
d455 1
a455 1
    if False:
d467 6
d481 1
d483 1
a483 1
dtMin = 1e-30
a484 1
dtMax = 2e-18
d486 1
d491 1
a491 1
energyFix = True
d496 4
a510 1
	
d512 22
a537 2
startingTotalE = None
excessEnergy = 0.0
d540 1
d559 43
a601 1
    if True:
d603 8
a610 34
	print
    	print "Time now is %25.40f" % now
	print "Total Momentum %8.1e %8.1e %8.1e" % totalMomentum(world)

	#########################################################################################
	### Calculate energy
	#########################################################################################

	totalKE = totalKeneticEnergy(world)
	totalPE = totalPotentialEnergy(world)

	global Bounce
	if Bounce or (startingTotalE is None):
	    print "Starting TOTAL RESET FROM", startingTotalE,
	    startingTotalE = totalKE + totalPE
	    print "TO", startingTotalE
	    Bounce = False

	print "Total ke     %8.1e" % totalKE, "change from last %8.1e" % (totalKE - lastKE)
	print "Total pe     %8.1e" % totalPE, "change from last %8.1e" % (totalPE - lastPE)
	print "Total    e:  %8.1e" % (totalKE + totalPE)
	print "Relative e:  %8.1e" % ((totalKE + totalPE) - startingTotalE)
	print "DT is: %4.1e" % dt

	if P1 is not None and P2 is not None:
	    print "Distance between P1 P2 %.10f" % (P1.distance(P2)/Angstrom)
	if P2 is not None and P3 is not None:
	    print "Distance between P2 P3 %.10f" % (P2.distance(P3)/Angstrom)
	if P1 is not None and P3 is not None:
	    print "Distance between P1 P3 %.10f" % (P1.distance(P3)/Angstrom)
	print

	lastKE = totalKE
	lastPE = totalPE
d612 1
a612 1
	#########################################################################################
d614 3
d618 1
a618 3
    if True:
	# Update forces all the particles place on each other according
	# to their current positions.
d620 3
a622 7
	for p1 in world:
	    p1.zeroForce()
	    for p2 in world:
	    	p1.addForce(p2)

	# Update velocity of all the particles according to the forces applied
	# And update position with new velocity
d631 8
a638 3
	    # curEnergy = totalEndKeneticEnergy(world) + totalEndPotentialEnergy(world)
	    # error = totalKE + totalPE - curEnergy
	    # print "Energy error after first position calc    %18.10e" % error
d645 24
a668 32
	    # curEnergy = totalEndKeneticEnergy(world) + totalEndPotentialEnergy(world)
	    # error = totalKE + totalPE - curEnergy
	    # print "Energy error after force update calc      %18.10e" % error

	    for i in range(len(world)):
		p1 = world[i]
		p1.calculateEndVelocity(dt)
		p1.calculateEndPosition(dt)

	    # curEnergy = totalEndKeneticEnergy(world) + totalEndPotentialEnergy(world)
	    # error = totalKE + totalPE - curEnergy
	    # print "Energy error after velocity and pos recal %18.10e" % error

	for i in range(len(world)):
	    p1 = world[i]
	    if isinstance(p1, Electron):
		sys.stdout.write('e')
	    else:
		sys.stdout.write('p')
	    print "%d vx:%10.2e  vy:%10.2e " % (i, p1.vx, p1.vy),
	    print "x:%10.5f Angstroms" % (p1.x/Angstrom)

	for p1 in world:
	    p1.move(dt)

	# Now calculate total Energy again

	totalKE2 = totalKeneticEnergy(world)
	totalPE2 = totalPotentialEnergy(world)

	energyDiff = (totalKE2 + totalPE2) - (totalKE + totalPE) # last move error only
	energyDiffStart = (totalKE2 + totalPE2) - startingTotalE # error from start
d674 2
a675 1
	print "energy diff for move is  ", energyDiff
d680 6
a685 2
	if False and cycleCount > 300:
	    sys.exit(1)
d691 1
a691 1
		print "SPEEDUP -- increase DT abs(diff)/total is", abs(energyDiff) / totalKE2
d694 4
a697 3
		for p1 in world:
		    p1.resetPositionAndVelocity()
		continue
d699 2
a700 2
	    if dt > dtMin and abs(energyDiff) / totalKE2 > 0.001:
		print "SLOWDOWN -- redeuce DT abs(diff)/total is", abs(energyDiff) / totalKE2
d704 1
a704 1
		    p1.resetPositionAndVelocity()
d708 1
a708 1
	# Adjust all velocities to remove energy error of energyDiffStart
d710 25
a734 1
	now += dt
d736 21
a756 29
	if energyFix:
	    if energyDiffStart > totalKE2:
		print "energy error greater than total KE error:", energyDiffStart, "total", totalKE2
	    	energyDiffStart = totalKE2 * 0.5
		# time.sleep(1)
		# sys.exit(1)

	    for i in range(len(world)):

		# print
		# print "Adjust KE for particle", i, "energyDiffStart error is", energyDiffStart
		p1 = world[i]
		ke = p1.keneticEnergy()
		# print "Current ke is", ke
		# print "percent of of total is", ke/totalKE2*100.0, "%"
		# print "amount added of total energyDiffStart is", ke/totalKE2*energyDiffStart
		newKe = ke - ke/totalKE2*energyDiffStart
		# print "new should be", newKe
		p1.setKeneticEnergy(newKe)
		# print "new KE is now", p1.keneticEnergy()

	    # totalKE3 = totalKeneticEnergy(world)
	    # totalPE3 = totalPotentialEnergy(world)
	    # energyDiff3 = (totalKE3 + totalPE3) - startingTotalE

	    # print "--- after energy adjustments ----"
	    # print "new totalKE after adjust is", totalKE3
	    # print "new totalPE after adjust is", totalPE3
	    # print "energy diff from start after adjust is", energyDiff3
@


1.8
log
@checkpoint
@
text
@d25 2
d41 1
a41 1
    def zeroForce(self):
d45 6
d52 1
a52 1
    def addForce(self, p):
d70 22
d93 15
a107 3
	self.endVx = self.vx + self.fx * dt / self.mass
	self.endVy = self.vy + self.fy * dt / self.mass
	self.endVz = self.vz + self.fz * dt / self.mass
a112 3
    	self.EndX = self.x + (self.vx + self.endVx) * dt / 2.0
    	self.EndY = self.y + (self.vy + self.endVy) * dt / 2.0
    	self.EndZ = self.z + (self.vz + self.endVz) * dt / 2.0
d114 19
a132 1
    def updatePosition(self, dt): # From End X Y Z
a135 3
	self.x = self.EndX
	self.y = self.EndY
	self.z = self.EndZ
d137 4
a140 2
    def updateVelocity(self, dt):
    	# update velocities from previously calculated end velocities
d144 1
d149 8
d169 4
d199 11
d213 3
d224 8
d360 1
a360 1
    spacing = 0.0000000001
a502 1
spacing = 0.0000000001
d504 1
d518 2
a519 2
	x = int(200 + 20.0 * self.p.x / spacing)
	y = int(200 + 20.0 * self.p.y / spacing)
a522 1
	global Bounce
d572 17
d594 6
a599 5
p1 = Electron(spacing * 0.0, 0.0, 0.0)
p1 =   Proton(spacing * 0.0, 0.0, 0.0)
e1 =   Proton(spacing * 1.0, 0.0, 0.0)
e1 = Electron(spacing * 3.0, 0.0, 0.0)
e1 = Electron(spacing * 1.0, 0.0, 0.0)
d601 1
d604 1
d606 6
a611 6
p2 =   Proton(spacing * 5.0, spacing * 2.0, 0.0)
e2 = Electron(spacing * 6.0, spacing * 2.0, 0.0)
p2 =   Proton(spacing * 2.0, spacing * 0.0, 0.0)
e2 = Electron(spacing * 3.0, spacing * 0.0, 0.0)
p2 =   Proton(spacing * 3.0, spacing * 0.0, 0.0)
e2 = Electron(spacing * 4.0, spacing * 0.0, 0.0)
d613 1
d615 2
a616 2
p3 =   Proton(spacing * 10.0, spacing * 0.0, 0.0)
e3 = Electron(spacing * 11.0, spacing * 0.0, 0.0)
d618 1
d621 2
a622 2
    p1 =   Proton(spacing * 0.0, 0.0, 0.0)
    e1 = Electron(spacing * 1.0, 0.0, 0.0)
d625 2
a626 2
    p2 =   Proton(spacing * 2.0, spacing * 0.0, 0.0)
    e2 = Electron(spacing * 8.0, spacing * 0.0, 0.0)
d661 1
a662 1
dt = 2e-17
d664 2
d667 4
d672 3
d720 2
a721 3
	print "---------"
    	print "Time now is %25.20f" % now
	print "               0.001001001000"
d738 4
a741 3
	print "Total ke %8.1e" % totalKE, "change from last %8.1e" % (totalKE - lastKE)
	print "Total pe %8.1e" % totalPE, "change from last %8.1e" % (totalPE - lastPE)
	print "Total e:  %8.1e" % ((totalKE + totalPE) - startingTotalE)
d743 1
d745 1
a745 1
	    print "Distance between P1 P2 %.10f" % (P1.distance(P2)/spacing)
d747 1
a747 1
	    print "Distance between P2 P3 %.10f" % (P2.distance(P3)/spacing)
d749 1
a749 1
	    print "Distance between P1 P3 %.10f" % (P1.distance(P3)/spacing)
d770 29
d801 6
a806 4
	    p1.calculateEndVelocity(dt)
	    p1.calculateEndPosition(dt)
	    p1.updatePosition(dt)
	    p1.updateVelocity(dt)
d808 2
a809 2
	    print "p%d velocity x,y is %10.2e %10.2e" % (i, p1.vx, p1.vy),
	    print "x spacing %10.5f" % (p1.x/spacing)
d816 2
a817 1
	energyDiff = (totalKE2 + totalPE2) - startingTotalE
d823 2
a824 1
	# print "energy diff after move is", energyDiff
d828 8
a835 3
	if totalKE != 0.0:
	    if cycleCount > 10 and abs(energyDiff) / totalKE < 0.001:
		print "SPEEDUP -- increase DT abs(diff)/total is", abs(energyDiff) / totalKE
d837 1
d842 2
a843 2
	    if dt > dtMin and abs(energyDiff) / totalKE > 0.01:
		print "SLOWDOWN -- redeuce DT abs(diff)/total is", abs(energyDiff) / totalKE
d845 1
d851 2
a852 1
	# Adjust all velocities to remove energy error of energyDiff
d855 29
a883 22
	for i in range(len(world)):

	    # print
	    # print "Adjust KE for particle", i, "energyDiff error is", energyDiff
	    p1 = world[i]
	    ke = p1.keneticEnergy()
	    # print "Current ke is", ke
	    # print "percent of of total is", ke/totalKE2*100.0, "%"
	    # print "amount added of total energyDiff is", ke/totalKE2*energyDiff
	    newKe = ke - ke/totalKE2*energyDiff
	    # print "new should be", newKe
	    p1.setKeneticEnergy(newKe)
	    # print "new KE is now", p1.keneticEnergy()

	totalKE3 = totalKeneticEnergy(world)
	totalPE3 = totalPotentialEnergy(world)
	energyDiff3 = (totalKE3 + totalPE3) - startingTotalE

	# print "--- after energy adjustments ----"
	# print "new totalKE after adjust is", totalKE3
	# print "new totalPE after adjust is", totalPE3
	# print "energy diff from start after adjust is", energyDiff3
@


1.7
log
@checkpoint with working simulation code. Sort of.
@
text
@d500 2
a501 2
p2 =   Proton(spacing * 5.0, spacing * 0.0, 0.0)
e2 = Electron(spacing * 6.0, spacing * 0.0, 0.0)
d530 1
a530 1
if False:
d533 3
a535 2
    pi4 = ParticleImage(e2)
    piworld.append(pi4)
d538 1
a538 1
if True:
@


1.6
log
@checkpoint
@
text
@d62 20
a81 12
    def calculateNewVelocity(self, dt):
	self.newVx = self.vx + self.fx * dt / self.mass
	self.newVy = self.vy + self.fy * dt / self.mass
	self.newVz = self.vz + self.fz * dt / self.mass

    def updatePosition(self, dt):
	# Update position using both old and new velocity
	# Assume constant acceleration -- so average of old
	# and new velocity is what is used to calculate new position
    	self.x += (self.vx + self.newVx) * dt / 2.0
    	self.y += (self.vy + self.newVy) * dt / 2.0
    	self.z += (self.vz + self.newVz) * dt / 2.0
d84 15
a98 4
    	# update velocities from previously calculated new velocities
	self.vx = self.newVx
	self.vy = self.newVy
	self.vz = self.newVz
d329 1
a329 1
	print "Total e:", totalKE + totalPE, "change from last", (totalKE - lastKE) + (totalPE - lastPE)
d414 1
d430 1
d432 1
d436 1
d440 1
d444 1
d448 1
a488 1
P1 = p1
d490 1
a491 2
#p1.vy = -1200000.0
e1.vy = 500000.0
d493 1
a494 2
e1.vy = 1200000.0
e1.vy = 100000.0
d496 6
a501 3
p2 =   Proton(spacing * 5.0, 0.0, 0.0)
e2 = Electron(spacing * 6.0, 0.0, 0.0)
P2 = p2
a503 4
p3 =   Proton(spacing * 3.0, spacing * 4.0, 0.0)
e3 = Electron(spacing * 4.0, spacing * 4.0, 0.0)
e3.vy = 1600000.0

a505 1
P3 = p3
d508 10
d519 3
d528 1
d535 1
d537 1
a537 1
if False:
d542 1
d548 1
d551 2
a552 2
dt = 2e-18

d576 2
a595 1

d598 4
a601 1
	print "Total momentum", totalMomentum(world)
d610 3
a612 1
	if startingTotalE is None:
d614 2
d617 10
a626 8
	print
	print "Total ke", totalKE, "change from last", totalKE - lastKE
	print "Total pe", totalPE, "change from last", totalPE - lastPE
	print "Total e:  %7.4e" % ((totalKE + totalPE) - startingTotalE)
	print "change from last %7.4e" % (((totalKE - lastKE) + (totalPE - lastPE)) - startingTotalE)
	print "Distance between P1 P2 %.10f" % (P1.distance(P2)/spacing)
	print "Distance between P2 P3 %.10f" % (P2.distance(P3)/spacing)
	print "Distance between P1 P3 %.10f" % (P1.distance(P3)/spacing)
a643 2
	# Total energy was calcated above as totalKE and totalPE

d649 2
a650 1
	    p1.calculateNewVelocity(dt)
d654 2
a655 1
	    print "p%d velocity x,y is" % i, p1.vx, p1.vy, "x spacing", p1.x/spacing
d662 1
a662 1
	energyDiff = (totalKE2 + totalPE2) - (totalKE + totalPE)
d664 23
a686 34
	print "old KE was", totalKE
	print "old PE was", totalPE
	print "new totalKE after move is", totalKE2
	print "new totalPE after move is", totalPE2
	print "energy change after move is", energyDiff
	print "excessEnergy is", excessEnergy

	if energyDiff > totalKE2:
	    print "--- ERROR ERROR ERROR energyDiff is greater than totalKE2", energyDiff, totalKE2
	    diff = totalKE2 * 0.99
	    excessEnergy += energyDiff - diff
	    energyDiff = diff
	    print "--- reduce energy diff to", energyDiff
	    #sys.exit(0)
	elif excessEnergy > 0.0:
	    # We have accumulated energy error in the system we must suck
	    # out -- however much will be left in the system after
	    # adjust below by energyDiff, take 50% more of it out.
	    keWeCanTakeOut = 0.5 * (totalKE2 - energyDiff)
	    print "keWecantakeout", keWeCanTakeOut
	    print "excessEnergy", excessEnergy
	    if keWeCanTakeOut > excessEnergy:
	    	takeOut = excessEnergy
	    else:
	    	takeOut = keWeCanTakeOut
	    print "take out", takeOut, "from excessEnergy", excessEnergy
	    excessEnergy -= takeOut
	    print "old energyDiff was", energyDiff
	    energyDiff += takeOut
	    print "new energyDiff is ", energyDiff
	if energyDiff > totalKE2:
	    print "Ops, fucked it up"
	    print "energyDiff", energyDiff, "totalKE2", totalKE2
	    sys.exit(1)
d688 2
a689 1
	# Adjust all velocities to remove energy error
d694 1
a694 1
	    # print "Adjust KE for particle", i, "energyDiff is", energyDiff
d698 2
a699 2
	    # print "percent of of total is", ke/totalKE2
	    # print "amount added of total is", ke/totalKE2*energyDiff
d702 1
a702 1
	    #p1.setKeneticEnergy(newKe)
d707 6
a712 4
	energyDiff3 = (totalKE3 + totalPE3) - (totalKE + totalPE)
	print "new totalKE after adjust is", totalKE3
	print "new totalPE after adjust is", totalPE3
	print "energy change after adjust is", energyDiff3
@


1.5
log
@two particle energy conserve for each particle update.
doesn't work, but wanted to checkpoint the code.
tried fixing energy change with each particle updated
one step at a time.
@
text
@d62 4
a65 9
    def updateVelocity(self, dt):
    	# update velocities from force
	# f = ma
	# a = f / m
	# v += a * dt
	# v += (f / m) * dt
	self.vx += self.fx * dt / self.mass
	self.vy += self.fy * dt / self.mass
	self.vz += self.fz * dt / self.mass
d68 12
a79 3
    	self.x += self.vx * dt
    	self.y += self.vy * dt
    	self.z += self.vz * dt
d89 10
a98 3
	self.vx *= newV2 / oldV2
	self.vy *= newV2 / oldV2
	self.vz *= newV2 / oldV2
d100 1
a100 2
    def potentialEnergy(self, p):
    	# potential energy between self and particle P
d109 10
a118 1
	d2 = dx ** 2.0 + dy ** 2.0 + dz ** 2.0
d120 1
a120 1
	return self.ke * self.charge * p.charge / math.sqrt(d2)
d279 2
a280 2
    lastKe = 0.0
    lastPe = 0.0
d291 2
a292 2
	totalKe = 0.0
	totalPe = 0.0
d299 1
a299 1
	    totalKe += ke
d306 1
a306 1
		totalPe += pe
d308 3
a310 3
	print "Total ke", totalKe, "change from last", totalKe - lastKe
	print "Total pe", totalPe, "change from last", totalPe - lastPe
	print "Total e:", totalKe + totalPe, "change from last", (totalKe - lastKe) + (totalPe - lastPe)
d313 2
a314 2
	lastKe = totalKe
	lastPe = totalPe
d409 2
d412 2
a413 1
	    self.p.vx = self.p.vx * -0.5
d415 2
a416 1
	    self.p.vx = self.p.vx * -0.5
d418 2
a419 1
	    self.p.vy = self.p.vy * -0.5
d421 2
a422 1
	    self.p.vy = self.p.vy * -0.5
d439 17
d463 1
a466 1
e1.vy = 1600000.0
d469 3
d475 2
a476 1
e2.vy = -1600000.0
d482 5
d488 6
a493 4
pi1 = ParticleImage(p1)
piworld.append(pi1)
pi2 = ParticleImage(e1)
piworld.append(pi2)
a510 2
dt = 2e-18
dt = 1e-18
d513 1
d516 2
a517 2
lastKe = 0.0
lastPe = 0.0
d537 1
d565 2
a566 17
	totalKe = 0.0
	totalPe = 0.0

	for i in range(len(world)):
	    p1 = world[i]
	    ke = p1.keneticEnergy() 
	    print "ke%d=%.3e" % (i, ke),
	    # print "vx%d=%.3e" % (i, p1.vx),
	    totalKe += ke
	    # for j in range(len(world)):
	    for j in range(i, len(world)):
		p2 = world[j]
		if p1 is p2:
		    continue
		pe = p1.potentialEnergy(p2)
		print "pe%d-%d=%.3e" % (i, j, pe),
		totalPe += pe
d569 1
a569 1
	    startingTotalE = totalKe + totalPe
d572 7
a578 4
	print "Total ke", totalKe, "change from last", totalKe - lastKe
	print "Total pe", totalPe, "change from last", totalPe - lastPe
	print "Total e:  %9.5f" % ((totalKe + totalPe) / startingTotalE),
	print "change from last %9.5f" % (((totalKe - lastKe) + (totalPe - lastPe))/startingTotalE)
d581 2
a582 2
	lastKe = totalKe
	lastPe = totalPe
d591 1
a591 5
	for i in range(len(world)):
	    # if i == 0 or i == len(world) - 1:
		# continue # don't move first or last
	    p1 = world[i]
	    force = 0.0
d595 2
a596 1
	    # print "p1 force is", p1.fx
a601 2
	    # if i == 0 or i == len(world) - 1:
		# continue # don't move first or last
d603 2
a604 1
	    totalE = p1.keneticEnergy() # use last velocity
a605 16
	    for j in range(len(world)):
	    	if i == j:
		    continue
		p2 = world[j]
		totalE += p1.potentialEnergy(p2)
	    p1.updatePosition(dt)
	    # Now adjust velocity to what it should be for it's new location
	    # keeping total energy constant
	    newPE = 0.0
	    for j in range(len(world)):
	    	if i == j:
		    continue
		p2 = world[j]
		newPE += p1.potentialEnergy(p2)
	    newKE = totalE - newPE
	    p1.setKeneticEnergy(newKE)
d607 47
d655 18
a672 1
	    print "p1 velocity x,y is", p1.vx, p1.vy
@


1.4
log
@Added pygame graphics!
@
text
@d36 1
a36 1
	self.ke = 8.9875517873681764e9  # Just the constant
d81 8
d103 14
d127 1
d375 1
d390 8
d400 14
a413 1
screen_size = screen_width, screen_height = 600, 400
d419 3
a421 1
p1 = Proton(spacing * 0.0, 0.0, 0.0)
d423 13
a435 4
p2 = Proton(spacing * 4.0, 0.0, 0.0)
e2 = Electron(spacing * 5.0, 0.0, 0.0)
p3 = Proton(spacing * 8.0, 0.0, 0.0)
e3 = Electron(spacing * 9.0, 0.0, 0.0)
d441 13
a453 8
pi3 = ParticleImage(p2)
piworld.append(pi3)
pi4 = ParticleImage(e2)
piworld.append(pi4)
pi5 = ParticleImage(p3)
piworld.append(pi5)
pi6 = ParticleImage(e3)
piworld.append(pi6)
d459 2
d462 18
a479 16
dt = 2e-17
p = world[0]
e = world[1]
e.vy = 1000000.0
e.vy = 2000000.0
e.vy = 1500000.0
e.vy = 1600000.0
e.vy = 1200000.0
# e.vy = 0.0
# p.vy = -160000.0
p = world[2]
e = world[3]
e.vy = -1600000.0
# e.vy = 0.0
# p.vy = 160000.0
world[5].vy = 1600000.0
d484 2
d505 42
d567 1
d569 5
d575 13
a587 1
	    # print "p1 velocity x,y is", p1.vx, p1.vy
@


1.3
log
@checkpoint.
@
text
@d18 7
d202 1
a202 1
    ## what freq does it osscilate at?
d247 1
a247 1
    	print "now is %8.4e" % now,
d251 1
d268 3
a270 1
	print "Total e:", totalKe + totalPe
d278 1
a278 1
    	print "now is %8.4e" % now,
d336 1
a336 1
	# Update velocity of all the electrons according to the forces applied
d349 115
a463 1
test2()
@


1.2
log
@5 electons in a row, first and last locked down three in middle free
to move.  Middle stays in place.  The other two oscilate in matching
inverted patterns at a frequency of 1.7 e+14 hz -- happens to fall in
the infarade range.  Cool.
@
text
@d37 2
a38 2
    def addForce(self, e):
    	if e is self:
d41 3
a43 3
	dx = (self.x - e.x)
	dy = (self.y - e.y)
	dz = (self.z - e.z)
d47 1
a47 1
	force = self.ke * (self.charge * e.charge) / d2
d60 1
d70 18
d104 1
a104 1
    ## energy to move thorugh the line of electrons. 
d193 144
d338 2
a339 1
test1()
@


1.1
log
@Initial revision
@
text
@a17 683
def sigmoid(x):
    # -inf < x < +inf
    # 0.0 < sigmoid(x) < 1.0
    # sigmoid(0) = 0.5
    return 1.0/(1.0 + math.exp(-x))

def dsigmoid(x):	# Derivitve of sigmoid function
    return sigmoid(x) * (1.0 - sigmoid(x))

def crtClear():
    sys.stdout.write("\033[2J")

def crtClearAndHome(row=0, col=0):
    crtClear()
    crtGOTO(row, col)

def crtGOTO(row, col):
    sys.stdout.write("\033[%d;%dH" % (row, col))

def crtMode(m=None):
    if m is None:
    	m = 0	# normal mode
    elif m == "normal":
    	m = 0
    elif m == "bold":
    	m = 1
    elif m == "underline":
    	m = 2
    elif m == "blinking":
    	m = 5
    elif m == "reverse video":
    	m = 7

    if m not in [0, 1, 2, 5, 7]:
    	raise Exception("Invlaid mode")
    
    sys.stdout.write("\033[%dm" % (m))

def printPD(list):
    s = sum(list)
    for i in range(len(list)):
    	print "%5.3f" % (list[i]*100.0/s),
    print

def randomPercent(n):
	# return TRUE, n % of the time.
	# randomPercent(10) returns true 10% of the time.
	return random.random() * 100 <= n

class Node:
    """ A single node of the network
    """
    def __init__(self, r=0, c=0, qValue=None, halfLife=None):
        self.at = ActivityTrace(halfLife)	# state value -- activity level
	self.atAvg = ActivityAvg(halfLife*100)
	self.atEnergy = ActivityAvg(halfLife*100)	# averge of (at-avg)^2
        self.pcount = 0				# number of pulses
        self.totalPCount = 0			# number of pulses
        self.r = r 				# my row in the network
        self.c = c 				# my column in the network
        self.links = [] 			# output links to downstream nodes
	self.backLinks = [] 			# links to upstream nodes

	self.qValue = 0.0

	if qValue is not None:
	    self.qValue = qValue	# init value

	self.linkVar = ActivityAvg(halfLife=halfLife)		# Track link update Varriance as measure of noise

	self.at.updateV(0)				# Force value greter than zero at start
	self.atAvg.updateAvg(0, self.at.getV(0))	# make non zero as well

    def addLink(self, link):
    	self.links.append(link)

    def addBackLink(self, link):
    	self.backLinks.append(link)

    def getV(self, time):
        return self.at.getV(time)

    def setV(self, s):
        self.at.setV(s)

    def updateV(self, time):
	return self.at.updateV(time)

    def show(self): # node show
        self.showrc()
        print "->",
        for x in self.links:
            x.nextNode.showrc()
        print

    def showrc(self):
        print "[%d,%d]" %(self.r, self.c),

class Link:
    def __init__(self, net, prevNode, nextNode, fanOut, qValue=None, halfLife=None):
        self.prevNode = prevNode ## upstreadm node
        self.nextNode = nextNode ## downstream node

	# add this link to the two nodes as well!
	prevNode.addLink(self);
	nextNode.addBackLink(self)

	self.at = ActivityTrace(halfLife=halfLife)	# Actual AT
	self.eat = ActivityTrace(halfLife=halfLife)	# Expected AT
	self.qValue = 0.0
	self.policy = 1.0/fanOut	# last used policy sort bias
	self.av = 0.0			# last a value used for debug

	if qValue is not None:
	    self.qValue = qValue

	r = random.random() * 0.00001	# small random to break starting symmetry which messes with min(a)

	self.sd = 1.0
	self.b = 1.0/fanOut + r
	self.w = 1.0/fanOut + r
	self.v = 1.0
	self.f = 1.0/fanOut + r		# Flow balancing variable

    def getV(self, time):
        return self.at.getV(time)

    def setV(self, s):
        self.at.setV(s)

    def updateV(self, clock):
	v = self.at.updateV(clock)
	return v

class ActivityTrace:
    # Exponential Decay Activity Tracker
    # Used to create the very important eligbility trace but is also
    # a general tools # for statisically tracking all sorts of activity.
    # Clock is measured in seconds.
    # halflife is measured in seconds.
    # Larger half life makes value change slower and represents longer average.
    # The value is tuned to report in approximate units of Updates per second. 
    # But an exponetial decay is not a real measure of units per second.
    # It's tuned for updates at once a second to report a value of 1.0.  But
    # for faster updates the value will be low, and for slower updates the
    # value will be high. 10 a second is 9.69 pps, 1 every 10 seconds is .13

    def __init__(self, halfLife=None):
    	self.v = 0.0
        self.lastClock = 0.0		# time of last v recalulation
	self.halfLife = 10.00		# our Default (works with ActivityAvg as well)

	if halfLife is not None:
	    self.halfLife = float(halfLife)

	# Old way 1 is the top of the waveform
	# self.inc = 1.0 - self.getDecay(1.0)	# Adjust factor to make units approximately Updates Per Second
	d = self.getDecay(1.0)
	# self.inc = (1.0 - d) / d		# Puts 1 at the bottom of the waveform.
	self.inc = 2.0*(1.0 - d) / (1.0 + d)	# Puts 1 in the middle of the waveform.

    def getV(self, clock):
	# Return current value of device at this point in time.
	# decay towards zero
	# Times must never go backwards -- we don't suport that.
	if clock < self.lastClock:
	    print
	    print "self.lastClock is", self.lastClock
	    print "clock is", clock
	    raise Exception("Time goes backwards -- not supported")
	if clock > self.lastClock:
            self.v *= self.getDecay(clock-self.lastClock)
            self.lastClock = clock
        return self.v

    def getDecay(self, dt):
	# Returns decay factor.  Returns 1 for a time difference of 0, and
	# less than one, for all times greater than 1.
	# Returns 1/2 for a time difference equal to the units halfLife
	# Returns 1/4 for 2*halfLife, etc.
	if dt == 0.0:
	    return 1.0
	return 2.0 ** (-dt/self.halfLife)

    def setV(self, v):
	# Questionable. Confusing. WARNING:  Doesn't update lastClock.
	# Call getV() first to make sure clock is updated
	# or else, this value will get discounted based
	# on last call to getV()
        self.v = v
	return self.v

    def updateV(self, clock, factor=1.0):
	# Discount old value, then Increment by self.inc
	# Called for every pulse that needs to be tracked.
	# "factor" is used for testing stuf.
	return self.setV(self.getV(clock)+self.inc*factor)

class ActivityAvg:
    # Running Average Calculator based on the same
    # Exponential Decay behavior of Activity Trace.
    # Was subclass of ActivityTrace.  But that created a
    # bug of me using updateV by mistake instead of updateAvg.
    # Changed to has-a instead of is-a to protect against these bugs.
    # ActivityTrace, uses the same time based discount on all values.
    # This version, adjusts the discounts so the sum of all discounts is 1.0
    # making it a weighted average.

    def __init__(self, halfLife=None):
    	self.avg = 0.0
	self.at = ActivityTrace(halfLife)

    def getAvg(self):
	return self.avg

    def updateAvg(self, clock, value):
	oldV = self.at.getV(clock)
	newV = self.at.updateV(clock)

	# Explaning the math:
	# newV is used to represent 100% of the average after adding in value
	# oldV is the precent of average that represets previous values
	# Also this is true: newV = oldV + inc
	# oldPercent is oldV/newV, and newPercent is 1 - oldPrecent
	# avg = avg * oldPercent + value * newPercent
	# This simplifies to:

	self.avg = value + (self.avg - value) * oldV / newV

	return self.avg

class Network:
    """ A network of nodes
        simple rectangular net for now.
        Input is on left, travels to right
        rows is number of inputs and outputs
        cols is number of layers
        row,col is zero based numbering
	0,0 is upper left corner 
    """
    def __init__(self, rows=2, cols=2, name="Network",
	    qValue=None,
	    halfLife=None,
	    qLearningSpeed=None,
	    bLearningSpeed=None,
	    sdRatio=None,
	    sLevel=None,
	    wLearningSpeed=None,
	    forceExploration=None,
	    wireBinary=False,
	    wireFanOut=3
	):
        self.nodes = []
        self.rows = rows
        self.cols = cols
        self.name = name
        self.time = 0.0
	self.lastSortTime = 0.0
	self.lastRewardUpdateTime = 0.0
        self.pulseCount = 0 # number pulses sorted
	self.startTime = time.time()	# real time clock
	self.halfLife = halfLife	# default halfLife for ActivityTrace objects
	self.qValue = qValue		# default starting qValue for network
	self.wireBinary = wireBinary
	self.wireFanOut = wireFanOut
	self.distanceBias = self.makeDistanceBias(self.wireFanOut)
	self.distanceBiasMax = max(self.distanceBias)
	# self.debugDistanceBias()

	self.qLearningSpeed = 0.000001	# default speed of reward learning - must be optimized for problem

	if qLearningSpeed is not None:
	    self.qLearningSpeed = qLearningSpeed

	self.qNodeLearningSpeed = math.sqrt(self.qLearningSpeed)

	self.bLearningSpeed = 0.001
	if bLearningSpeed is not None:
	    self.bLearningSpeed = bLearningSpeed

	self.sdRatio = 1000.0
	if sdRatio is not None:
	    self.sdRatio = sdRatio

	self.sLevel = sLevel

	self.wLearningSpeed = 0.0001
	if wLearningSpeed is not None:
	    self.wLearningSpeed = wLearningSpeed

	self.forceExploration = 0.01	# 1 percent forced use of all links to make qValues keep converging
	if forceExploration is not None:
	    self.forceExploration = forceExploration
	if self.forceExploration <= 0.0 or self.forceExploration > .99:
	    raise Exception("forceExploration must be greater than zero such as 0.01 for 1%")

	self.qMean = ActivityAvg()			# running average of Q values
	self.qMean2 = ActivityAvg(halfLife=1e5)	# very slow running average of Q values

	self.avgRewards = ActivityAvg()			# running average of rewards
	self.avgRPS = ActivityTrace()			# rewards per second
	self.avgRPS2 = ActivityAvg(halfLife=1e5)	# avg of avg

	self.rowHistogram = Histogram(self.rows)

	self.lastShowTime = time.time()
	self.lastShowPulseCount = self.pulseCount

	self.predictLRightCount = [0]*(self.cols-1)
	self.predictLWrongCount = [0]*(self.cols-1)
	self.predictHRightCount = [0]*(self.cols-1)
	self.predictHWrongCount = [0]*(self.cols-1)

        for r in range(rows):
            col = self.mkcol(r, cols)
            self.nodes.append(col)

        self.wire()

    def resetCounts(self):
    	""" Reset row output pulse counts.
	"""
	self.rowHistogram.resetCounts()

    def resetState(self, value=0.0):
        for r in range(self.rows):
	    for c in range(self.cols):
		self.nodes[r][c].setV(value)

    def mkcol(self, r, cols):
        col = []
        for c in range(cols):
            col.append(Node(r, c, qValue=self.qValue, halfLife=self.halfLife))
        return col

    def debugDistanceBias(self):
    	for fo in range(10):
	    b = self.makeDistanceBias(fo)
	    print "fanout %d: " % fo,
	    for i in range(len(b)):
	    	print "%5.3f" % b[i],
	    print
	sys.exit()

	## 1.0/((i-middle)^2 + 10):
	## fanout 0: 
	## fanout 1:  1.000
	## fanout 2:  0.500 0.500
	## fanout 3:  0.323 0.355 0.323
	## fanout 4:  0.228 0.272 0.272 0.228
	## fanout 5:  0.168 0.214 0.235 0.214 0.168
	## fanout 6:  0.128 0.170 0.203 0.203 0.170 0.128
	## fanout 7:  0.099 0.135 0.172 0.189 0.172 0.135 0.099
	## fanout 8:  0.079 0.108 0.143 0.171 0.171 0.143 0.108 0.079
	## fanout 9:  0.063 0.087 0.118 0.150 0.165 0.150 0.118 0.087 0.063
	    	
    def makeDistanceBias(self, wireFanOut):
    	""" create a distance bias probablity distribution
	    used in the policy to bias the flow to "closer" links.
	    Returns a list with real numbers.
	    Randomly trying a index distance squared bias formula that "looks" good
	    See above for what it looks like.
	"""
	middle = (wireFanOut - 1.0) / 2.0	# Will be 1.5 for for 0 1 2 3 (aka 4), or 1 for 0 1 2 (aka 3)
	bias = []
	for i in range(wireFanOut):
	    bias.append(1.0 / ((i-middle)**2.0 + 10.0))

	# Normalize into a Probablity Distribution
	s = sum(bias)
	for i in range(wireFanOut):
	    bias[i] /= s

	return bias


    def show(self, title=None, now=None,
	    doB=True,
	    doW=True,
	    doQ=None,
	    doNodeQ=False,
	    doLinkQ=False,
	    doTrack=True):

	# Network show (print)
        if now is None:
            now = self.time
        self.time = now

	if doQ is not None:	# Set both link and node display
	    doLinkQ = doQ
	    doNodeQ = doQ

        if title:
            print title,

        print self.name, self.rows, "x", self.cols,

	seconds = self.time
	hours = int(seconds / 3600.0)
	seconds -= hours * 3600.0
	minutes = int(seconds / 60.0);
	seconds -= minutes * 60.0
	print " time: %d:%02d:%07.4f" % (hours, minutes, seconds),

	end = time.time()
	print " PPS ", int((self.pulseCount-self.lastShowPulseCount) / (end-self.lastShowTime)),

	print " RPS %.3f %.3f " % (self.avgRPS.getV(now) , self.avgRPS2.getAvg())

	self.lastShowTime = time.time()
	self.lastShowPulseCount = self.pulseCount

	print "Explore: %.2f%%" % (self.forceExploration*100.0),
	print " Q: %.0e" % self.qLearningSpeed,
	print " B: %.0e" % self.bLearningSpeed,
	if self.sLevel is not None:
	    print " SL: %.0e" % self.sLevel,
	else:
	    print " SDR: %.0f" % self.sdRatio,
	print " W: %.0e" % self.wLearningSpeed,
	print " halfLife: %s" % self.nodes[0][0].at.halfLife,
	print " fanOut: %d" % self.wireFanOut

        for r in range(self.rows):
	    if True:
		for c in range(self.cols):
		    node = self.nodes[r][c]
		    print self.fmtNum(node.getV(now)*10.0, 3),	## state value
		    if doTrack:
			if node.pcount > 0:
			    sys.stdout.write("o")
			    node.pcount = 0
			else:
			    sys.stdout.write(" ")
		    if node.totalPCount > 0:
			#print self.fmtNum(node.qLogFlowFactor*100.0, 6),
			#print self.fmtNum(node.qValue*100.0, 3),
			#print "%8.4f" % node.qValue,
			if doB:
			    for l in node.links:
				self.printPercentDigit(l.b*10)
			    if len(node.links) > 0:
				sys.stdout.write(".")
			if doW:
			    for l in node.links:
				# print self.fmtNum(l.w*100.0, 3),		## link w values
				self.printPercentDigit(l.w*10)
			    if len(node.links) > 0:
				sys.stdout.write(".")
			bwSum = 0.0
			for l in node.links:
			    bwSum += l.b*l.w
			if False:
			    for l in node.links:
				self.printPercentDigit(l.b*l.w*l.nextNode.getV(now)*10.0/bwSum)
			    if len(node.links) > 0:
				sys.stdout.write(" ")
			if doNodeQ:
			    print "%5.2f" % node.qValue,
			if doLinkQ:
			    if len(node.links) > 0:
				qValues = []
				for l in node.links:
				    qValues.append(l.qValue)
				qMax = max(qValues)
				for l in node.links:
				    # print self.fmtNum(l.qValue*100.0, 5),	## link q values
				    if l.qValue == qMax:
					crtMode("reverse video")
				    sys.stdout.write("%5.2f " % l.qValue)
				    if l.qValue == qMax:
					crtMode("normal")
			if False:
			    for l in node.links:
				print self.fmtNum(l.getV(now)*10.0, 3),	## link a values
		    else:
			if doB:
			    for l in node.links:
				sys.stdout.write(" ")	# b
			    if len(node.links) > 0:
				sys.stdout.write(" ")
			if doW:
			    for l in node.links:
				sys.stdout.write(" ")	# w
			    if len(node.links) > 0:
				sys.stdout.write(" ")
			if False:
			    for l in node.links:
				sys.stdout.write(" ")	# bw
			    if len(node.links) > 0:
				sys.stdout.write(" ")
			if doNodeQ:
			    print "     ",
			if doLinkQ:
			    for l in node.links:
				print "     ", # q values
		    if doB or doW or doNodeQ or doLinkQ:
			sys.stdout.write("|")
		print " ",
	    if self.rowHistogram.counts[r] > 0:
		print "%5d " % (self.rowHistogram.counts[r]),
		self.rowHistogram.printBar(r)
	    print
            #time.sleep(0.01)

    def printPercentDigit(self, n):
    	if n <= 0.0:
	    sys.stdout.write(".")
    	elif n >= 10.0:
	    sys.stdout.write("X")
	else:
	    d = int(n+.5)
	    if d > 9:
	    	d = 9
	    sys.stdout.write("%1d" % d)

    def fmtNum(self, v, width):
	s = "[fmtNum Error]"
	if v > -0.1 and v < 0.1:
	    s = "  ."
	else:
	    s = "%.0f" % v
	    if len(s) > width:
		s = ""
		if v < 0.0:
		    s = "-"
		while len(s) < width:
		    s = s + "*"
	if len(s) < width:
	    while len(s) < width:
		s = " " + s
	return s

    def showNode(self, row, col, title=None, now=None):
    	# Do a high res dump of a node and the links
	# that fan out from it.
	if now is None:
	    now = self.time
	clock = now
	node = self.nodes[row][col]
	print "Node [%d][%d] %8.5f %8.5f" % (row, col, node.qValue, node.at.getV(clock)),
	linkSD = math.sqrt(node.linkVar.getAvg())
	print "  LinkSD*SDR %.8f %.2e" % (linkSD*self.sdRatio, linkSD*self.sdRatio)

	q = []
	b = []
	w = []
	a = []
	bwa = []
	pa = []
	p = []
	sd = []
	e = []
	for i in range(len(node.links)):
	    l = node.links[i]
	    q.append(l.qValue)
	    b.append(l.b)
	    w.append(l.w)
	    x = l.nextNode.getV(clock)
	    # a.append(x)
	    a.append(l.av)
	    p.append(l.policy)
	    pa.append(l.policy*l.av)
	    bwa.append(l.b*l.w*x)
	    sd.append(l.sd)
	    e.append(l.nextNode.atEnergy.getAvg())
	bSum = sum(b)
	wSum = sum(w)
	aSum = sum(a)
	bwaSum = sum(bwa)
	qMax = max(q)
	pSum = sum(p)
	paSum = sum(pa)
	sdSum = sum(sd)

	sdb = []
	for i in range(len(node.links)): # needed qMax first
	    sdb.append(self.bValue(q[i], qMax, None, node=node))

	sdbSum = sum(sdb)

	if sdbSum != 0:
	    for i in range(len(node.links)):
	    	sdb[i] /= sdbSum
	    sdbSum = sum(sdb)

	if False and aSum != 0:
	    for i in range(len(node.links)):
		a[i] /= aSum
	    aSum = sum(a)

	if paSum != 0.0:
	    for i in range(len(node.links)):
		pa[i] /= paSum
	    paSum = sum(pa)

	for line in [0, 4, 5, 7, 8] :
	    if line == 0:
	    	print " at:",
	    elif line == 1:
		print "  q: ",
	    elif line == 2:
		print "qsd:",
	    elif line == 3:
		print "bsd:",
	    elif line == 4:
		print "  b:",
	    elif line == 5:
		print "  w:",
	    elif line == 6:
	    	print "  p:",
	    elif line == 7:
		print "  a:",
	    elif line == 8:
		print " pa:",
	    elif line == 9: # Energy
		print "  e:",
	    elif line == 10:
		print "eat:",

	    for i in range(len(node.links)):
		l = node.links[i]
		if line == 0:
		    print "%12.8f     " % l.getV(clock),
		elif line == 1:	# Q
		    if l.qValue == qMax:
			crtMode("reverse video")
		    sys.stdout.write("%12.8f " % (l.qValue))
		    if l.qValue == qMax:
			crtMode("normal")
		    sys.stdout.write("     ")
		elif line == 2: # QSD
		    print "%12.2f" % (self.sdValue(l.qValue, qMax, linkSD)),
		    if sdbSum == 0.0:
		    	print "    ",
		    else:
		    	print "%3d " % (sdb[i]*100.0/sdbSum),
		elif line == 3: # BSD
		    if bSum == 0.0:
			print "%12.2f *** " % (l.sd),
		    else:
			print "%12.2f %3d " % (l.sd, l.b*100.0/bSum),
		elif line == 4:
		    if bSum == 0.0:
			print "%12.8f *** " % (l.b),
		    else:
			print "%12.8f %3d " % (l.b, l.b*100.0/bSum),
		elif line == 5:
		    print "%12.8f %3d " % (l.w, l.w*100.0/wSum),
		elif line == 6:
		    if pSum == 0.0:
			print "%12.8f %3d " % (p[i], 0.0),
		    else:
			print "%12.8f %3d " % (p[i], p[i]*100.0/pSum),
		elif line == 7:
		    if aSum == 0.0:
			print "%12.8f %3d " % (a[i], 0.0),
		    else:
			print "%12.8f %3d " % (a[i], a[i]*100.0/aSum),
		elif line == 8:
		    if paSum == 0.0:
			print "%12.8f %3d " % (pa[i], 0.0),
		    else:
			print "%12.8f %3d " % (pa[i], 100.0*pa[i]/paSum),
		elif line == 9: # Energy
		    print "%12.8f     " % e[i],
		elif line == 10: # eat
		    print "%12.8f     " % l.eat.getV(clock),
	    print


    def wire(self):
	""" Create links to wire the nodes together
		nodes fan-out according to self.wireFanOut
		Eac node wires to the same nodes in the next
		layer with the given fan-out offset.
		A fanout of 3 wires them from row-1 to row+1
		a fanout of 5 wires them from row-2 to row+2 etc.
		The fanout wraps around from the bottom of thet
		net to the top creating a logical cylindar 
		configuration.
	"""
d19 129
a147 617
	if self.wireBinary:
	    self.binaryTreeWire()	# do binary wire pattern instead
	    return

	self.wireFanOut = int(self.wireFanOut)

	if self.wireFanOut < 1 or self.wireFanOut > self.rows:
	    raise Exception("Invalid wireFanOut: %d" % self.wireFanOut)

	offset = int((self.wireFanOut-1) / 2)	# row offset for first fan-out connection

        for c in range(self.cols-1):
            for r in range(self.rows):
                for r2 in range(r-offset, r-offset+self.wireFanOut):
                    Link(self, self.nodes[r][c], self.nodes[r2%self.rows][c+1], self.wireFanOut, qValue=self.qValue, halfLife=self.halfLife)

	# self.showWire()
	# sys.exit()

    def binaryTreeWire(self):
    	#
	# Binary output, with branching tree to force
	# spreading of data exponeitionally.  Very hard
	# to debug and understand but far better
	# for operation of net.
	# BUT -- will create flat probablity distribution of output signal
	# which might not be good.  The signals might need to form a normal distribution
	# bell curve with different shapes on outputs to create non-linear output maps.
	# Hard to know if this is importat at this point.
	#
	# 2016-02-13 My recent thinking is that this was a good idea for pulse routing but a bad
	# idea for percpetion learning.  Percepeton learning works far better I think with
	# wide fanouts.
	#
	offset = 1
        for c in range(self.cols-1):
            for r in range(self.rows):
		Link(self, self.nodes[r][c], self.nodes[r][c+1], 2, qValue=self.qValue, halfLife=self.halfLife)
		Link(self, self.nodes[r][c], self.nodes[(r+offset)%self.rows][c+1], 2, qValue=self.qValue, halfLife=self.halfLife)
	    offset *= 2
	    if offset > self.rows:
		    offset = 1
        #self.showWire()

    def showWire(self):
        print self.name, self.rows, "x", self.cols
        for c in range(self.cols):
            for r in range(self.rows):
                self.nodes[r][c].show()
            print

    def sort(self, row, clock, doDebug=False):
        """ Sort pulse through network
            return row of output
        """
        self.pulseCount += 1
        curNode = self.nodes[row][0] # current node

	if clock < self.time:
	    raise Exception("Time goes backards on sort() -- not supported")
	    # Mutlpile pulses sorted with the same time is supported

        self.time = clock	# set network time, to "now"

	while True:
	    #
	    # Update node state value as pulse passes through it
	    #

	    a = curNode.at.updateV(clock)		# eligbility trace update for nodes
	    avg = curNode.atAvg.updateAvg(clock, a)
	    energy = curNode.atEnergy.updateAvg(clock, (a-avg)**2)

	    curNode.pcount += 1
	    curNode.totalPCount += 1

	    numLinks = len(curNode.links)

	    self.qMean.updateAvg(clock, curNode.qValue)
	    self.qMean2.updateAvg(clock, self.qMean.getAvg())

	    if len(curNode.links) == 0:
	    	break		# no ouputs, end of network

	    ############################################################################
	    #
	    # Route pulse -- pick which link to follow -- this is the policy code
	    #
	    ############################################################################

	    # 2016-02-10 rewrite.  Use b*w*a now. A is output flow volume from other links.
	    # 2016-02-14 added distance bias feature

	    aValues = []		# node eligiblity trace activty level (0 to ...)
	    for l in curNode.links:
		l.av = l.nextNode.getV(clock)
		aValues.append(l.av)

	    if True:
		# Add in a 1% force explore like effect to a value
		# Very important for ultra short halfLife where 'a' can go to zero
		# Also important to learning -- when it drops to near zero the 
		# balance learning can't force it to come back faster than it
		# falling to zero!
		# But maybe the force explore below is the better way?
		s = sum(aValues)
		for i in range(numLinks):
		    aValues[i] += s * 0.01
		    l = curNode.links[i]
		    l.av = aValues[i]

	    # Policy includes b*w*distanceBias but not activity
	    # This (was) is important in reward updates (not anymore since we use eat instead of rpolocy)

	    rpValues = []
	    for i in range(numLinks):
		l = curNode.links[i]
		# l.policy = l.b * l.w * self.distanceBias[i]
		# l.policy = l.w * self.distanceBias[i]
		# l.policy = l.f * l.b   # RL and balance only
		# l.policy = l.w * l.f * l.b
		if curNode.c < int(self.cols / 2):
		    # percpetion only in first half of net
		    l.policy = l.w * l.f
		else:
		    # Everything in second half?
		    # l.policy = l.w * l.f * l.b
		    # Only RL in second half?
		    l.policy = l.b
		# l.policy = l.f * l.b   # RL and balance only
		# l.policy = l.w * l.f * l.b # everything everwhere
		rpValues.append(l.policy)

	    if False:
		# For testing RL add in forceExploration to policy to use in routing
		# Otherwise, we wait to do this after the *a
		s = sum(rpValues)
		for i in range(numLinks):
		    l = curNode.links[i]
		    l.policy = (rpValues[i] / s) * (1.00 - (self.forceExploration * numLinks)) + self.forceExploration

	    pValues = [] # non normalized probiblity distribution b*w*a

	    for i in range(numLinks):
		l = curNode.links[i]
		pValues.append(l.policy*aValues[i])		# that's the main sort policy

	    if True:
		# Apply forceExploration to policy
		# Turned off for testing with RL only
		s = sum(pValues)
		if s == 0.0:
		    # Happens at startup when all a values are zero
		    for i in range(numLinks):
		    	pValues[i] = 1.0
		    s = sum(pValues)
		for i in range(numLinks):
		    pValues[i] = (pValues[i] / s) * (1.00 - (self.forceExploration * numLinks)) + self.forceExploration

	    numLinks = len(curNode.links)
	    choice = self.pickDistribution(pValues) 	# pick link for pulse to follow
	    curLink = curNode.links[choice]		# The link I picked
	    nextNode = curLink.nextNode			# The node it leads to

	    ############################################################################
	    #
	    # We have chosen which link to take.
	    #
	    # numLinks is the number of forward links.
	    # choice is the index of the link.
	    # curLink is now the chosen link to travel down.
	    # nextNode is the downStream Node.
	    #
	    ############################################################################

	    ############################################################################
	    #
	    # Update Expected AT for each link using probablity distributions
	    # We just picked from.  Unsure if this should include perception
	    # adjustments or just RL adjustment? policy? pValue?
	    # But at the moment, percpetion is turned off, so I'll just code with pValue
	    #
	    ############################################################################

	    # Warning, p values must be normalized for this to work!
	    for i in range(numLinks):
		l = curNode.links[i]
		l.eat.updateV(clock, factor=pValues[i])

	    ############################################################################
	    #
	    # Update b (balance weights) 
	    # b learning
	    #
	    ############################################################################

	    if True:
	    	# 2016-03-01 Directly calucate b values from q values based on
		# standard deviation of noise.
		# 2016-03-04 Try to slow the change by averaging in the new value with the old
		# 2016-03-04 The above worked great.  But now trying something even better.
		#            Track an sd value per link and update THAT slowly instead of the b value.


		linkSD = math.sqrt(curNode.linkVar.getAvg())

		links = curNode.links
		qMax = links[0].qValue
		for i in range(1, numLinks):
		    q = links[i].qValue
		    if q > qMax:
			qMax = q

		sdMin = curNode.links[0].sd
		for i in range(numLinks):
		    l = curNode.links[i]
		    sd = self.sdValue(l.qValue, qMax, linkSD)
		    l.sd += (sd - l.sd) * self.bLearningSpeed
		    if l.sd < sdMin:
		    	sdMin = l.sd

		# Normalize sd values back to make the smallest equal to zero
		for i in range(numLinks):
		    l = curNode.links[i]
		    l.sd -= sdMin

		# Now Convert sd values to b values!
		bSum = 0.0
		for i in range(numLinks):
		    l = curNode.links[i]
		    l.b = 2.0 ** (-l.sd)
		    bSum += l.b

		# And normlalize
		for i in range(numLinks):
		    l = curNode.links[i]
		    l.b /= bSum

		if False:
		    # from first attempt at SD/b learning
		    bSum = 0.0
		    bList = []
		    for i in range(numLinks):
			l = curNode.links[i]
			if l.qValue == qMax or linkSD == 0.0:
			    b = 1.0
			else:
			    b = self.bValue(l.qValue, qMax, linkSD)
			bSum += b
			bList.append(b)

		    for i in range(numLinks): # normalize
			bList[i] /= bSum

		    # Move all the current b values a bit towards this new target
		    for i in range(numLinks): # normalize
			l = curNode.links[i]
			l.b += (bList[i] - l.b) * self.bLearningSpeed

	    if False:
		# 2016-02-09 b is now the probability that this link is the max qValue

		links = curNode.links
		qMax = links[0].qValue
		allTheSame = True
		for i in range(1, numLinks):
		    q = links[i].qValue
		    if q == qMax:
			continue
		    allTheSame = False
		    if q > qMax:
			qMax = q

		if not allTheSame:
		    # Don't update if the q values are all the same!
		    # This just causes us to increment all three b values.
		    # That happens when qLearning is turned off or
		    # no rewards() have been sent. Or could happen by accident
		    # in normal operation but I think (hope) it's ok
		    # to not do updates in that case.
		    # What I'm mostly doing here, is preventing all qValues
		    # from being the same to cause all b values to be the
		    # same and just keep martching up to 1.0 in unison.
		    # Not a real problem currently based on how
		    # b values are used, but feels wrong, so I'm stopping it.
		    # Will probably delete for speed reasons later if I decide
		    # there's no point to this check.
		    for i in range(numLinks):
			l = curNode.links[i]
			if l.qValue == qMax: # could be duplicates 
			    l.b += (1.0 - l.b) * self.bLearningSpeed
			else:
			    l.b += (0.0 - l.b) * self.bLearningSpeed

	    ############################################################################
	    #
	    # Update f (flow balancing) values
	    # f learning
	    #
	    ############################################################################

	    # Calculate a Values again because we fudjed them to add 1% forceExplore above

	    # aValues = []
	    # for l in curNode.links:
		# l.av = l.nextNode.getV(clock)
		# aValues.append(l.av)

	    # aMinIndex = aValues.index(min(aValues)) # ignore issue of dups
	    # aMaxIndex = aValues.index(max(aValues)) # ignore issue of dups

	    if True:
	    	# Next idea.  Measure the pulse flow output imblance and
		# biase by that.  Not the output node blance.  if every
		# node is trying to blance pulse flow, the whole net
		# will seek towards total balance as well, without the
		# system every having to worry about actual blanace at
		# so, just punish path taken reward all others.
		# Wait, fuck, this is just the opposit of the back learning!
		# We tried this.
		# Maybe, when we do it as two separate factors, it will work!
		# This didn't work when we did it both with the one w
		# learning varible.
		for i in range(numLinks):
		    l = curNode.links[i]
		    if l == curLink:
			l.f += (0.0 - l.f) * self.wLearningSpeed
		    else:
			l.f += (1.0 - l.f) * self.wLearningSpeed 

	    if False:
		# f values measure the imblance
		# So 2:1 imblance wold set f to 2:1 (or 1:2 actually)
		# So this won't keep changing until balanced, it will just
		# seek a point where the adjustment was equal to the imblance.
		# In theory.
		s = sum(aValues) # normalize aValues by sum()
		avgA = s / numLinks
		for i in range(numLinks):
		    l = curNode.links[i]
		    l.f += (1.0 - l.f) * self.wLearningSpeed 
		    l.f += (0.0 - l.f) * self.wLearningSpeed * aValues[i] / avgA

	    ############################################################################
	    #
	    # Update w (weight) values for the outgoing links I just picked a path from.
	    # w learning
	    #
	    ############################################################################

	    if True:
	    	# 2016-03-23 new idea for the day.  Winner!
		# Train backwards, reward sort path, punish the rest!

		for i in range(len(nextNode.backLinks)):
		    l = nextNode.backLinks[i]
		    if l == curLink: # punish all but the path back to our input
			l.w += (1.0 - l.w) * self.wLearningSpeed
		    else:
			l.w += (0.0 - l.w) * self.wLearningSpeed

	    if False:
		# Always punish high reward low
		# Was the best before trying 100 other options and
		# discovering the info max back learning above!
		# And the f learning above that is doing the balancing work now
		# instead of this.

		l = curNode.links[aMaxIndex]
		l.w += (0.0 - l.w) * self.wLearningSpeed

		l = curNode.links[aMinIndex]
		l.w += (1.0 - l.w) * self.wLearningSpeed

	    ##################################################################
	    # End of w learning updates
	    ##################################################################

	    #
	    # We are passing through link curLink
	    # Update link V
	    #

	    curLink.updateV(clock)	# eligiblity trace update for links

            # Advance to next node
            curNode = nextNode

	    # Loop back and do next node in path now 

	# All done. CurNode is the output node

	self.rowHistogram.counts[curNode.r] += 1
	self.lastSortTime = self.time

        return curNode.r

    def bValue(self, qValue, qMax, linkSD, node=None):
	# Return unnormalized b value for the given qValue in a node
	# returns 1.0 for the max value and numbers less than 1 for
	# the rest.  These must be normalized to represent sort ratios.
	if qMax == None:
	    for l in node.links:
		if qMax == None or l.qValue > qMax:
		    qMax = l.qValue

	if linkSD == None:
	    linkSD = math.sqrt(node.linkVar.getAvg())

	return 2.0 ** (-self.sdValue(qValue, qMax, linkSD))

    def sdValue(self, qValue, qMax, linkSD):
	if self.sLevel is not None:
	    return (qMax-qValue) / self.sLevel
	if linkSD == 0.0:
	    return 0.0
	return (qMax-qValue) / (linkSD * self.sdRatio)
    	
    def gaussian(self, x, mean, var):
	x = float(x)
	# NOTE: the number returned is not a probablity, the area under the curve is 1.0!
	# For small values of var, the peak will be greater than 1!
	# I was confused by this for hours!  Stupid me.
	return  math.exp(-((x-mean)**2)/(2.0 * var)) / math.sqrt(2.0*math.pi*var)

	# return  math.exp(-((x-mean)**2)/(2.0 * var))	# This is 1.0 at mean (the peak of the bell curve)

    def pickSqDistribution(self, weights):
    	# use squared weights as probablities
	sqWeights = weights[:]
	for i in range(len(sqWeights)):
	    sqWeights[i] *= sqWeights[i]
	choice = self.pickDistribution(sqWeights)
	## print "sq weights ", sqWeights
	return choice

    def pickDistribution(self, weights):
	# return random index into list of weigths as
	# used as a probablity distribution that need not
	# sum to 1.0
	x = random.random() * sum(weights)	## 0.0 to sum(weights)
	choice = len(weights)-1
	for l in range(len(weights)):
	    x -= weights[l]
	    if x <= 0.0:
		choice = l
		break
	return choice

    def pickMax(self, weights):
	# return index of max weight
	# made complex to deal with ties
	m = max(weights)
	choice = len(weights)-1
	picks = []
	for l in range(len(weights)):
	    if weights[l] == m:
		picks.append(l)
	return random.sample(picks, 1)[0]

    def reward(self, clock, rewardValue, doDebug=False):
	# Apply reward to all q values
	# Works fine to send multiple rewards at the same clock tick time.
	# But it's far more CPU effecent to add the values and send
	# it as one reward since this is a very expensive operation (updates every node)

	self.avgRewards.updateAvg(clock, rewardValue)
	self.avgRPS.updateV(clock, factor=rewardValue)

	self.avgRPS2.updateAvg(clock, self.avgRPS.getV(clock))

	dt = clock - self.lastRewardUpdateTime
	at = self.nodes[0][0].at		# grab a random Activity Trace object
	discount = at.getDecay(dt)
	self.lastRewardUpdateTime = clock

	# at.inc is matched to discount to make convergence
	# target be approximately rewards per second.

	rewardInc = rewardValue * at.inc

	# self.avgRPSQ += (rewardInc + discount * self.avgRPSQ - self.avgRPSQ) * 0.001

	if doDebug:
	    print "--------------"
	    print "avgRewards     %7.4f" % self.avgRewards.getAvg()

	    print "avgRPS         %7.4f" % self.avgRPS.getV(clock),
	    print " %7.4f" % self.avgRPS2.getAvg()

	    print "qMean:         %7.4f" % self.qMean.getAvg(),
	    print " %7.4f" % self.qMean2.getAvg(),
	    m = (self.qMean.getAvg() - self.qMean2.getAvg())
	    if m > 0:
	    	print "  Happy!"
	    else:
	    	print "  Sad!"

	    print
	    print "reward:        %13.10f" % rewardValue

	# spread reward through entire network! # credit assignment to all nodes based on
	# recent activity logged by ActivityTrace -- most active get most the reward.
	# Each q value is used as its own predictor of future rewards.

	for r in range(self.rows):
	    for c in range(self.cols):
		node = self.nodes[r][c]
		if node.totalPCount == 0:		# Unused Node
		    continue

		# Update node qValue first

		if doMean:
		    qFuture = self.qMean.getAvg()
		else:
		    qFuture = node.qValue	# use the node as it's own predictor

		node.qValue += ((rewardInc + discount * qFuture - node.qValue) *
				    node.getV(clock) * self.qNodeLearningSpeed)

		# Then link qValues.  It might be better to do it in the other order?
		# It might not make any real difference what the order is?

		numLinks = len(node.links)

		for i in range(numLinks):
		    # link values are relative to the feed node qValue now.
		    # So the true qValue is nodeQ + linkQ

		    # Link qs are high resolution adjustments to the nodeQ.
		    # Node q learning is sqrt(linkQLearningSpeed) so the
		    # nodes learn the first n digits of precision of the
		    # value, and the links learn the rest.

		    # Update is basically the same as for nodes:
		    3
		    #   target = reward + q * discount
		    #   q += (target - q) * (activityTrace/policy) * LearningSpeed
		    #
		    # The policy adjust to activityTrace factors out the expected
		    # differences in flow volume due to long term learning so
		    # q learning is only based on short term activity differences.

		    l = node.links[i]

		    # zzz

		    linkTD = 0.0

		    if l.eat.getV(clock) != 0.0:	# can happen at startup -- catch divide by zero issue
			linkTD += ((rewardInc + node.qValue * discount - node.qValue) *
				node.at.getV(clock) * l.at.getV(clock) * self.qLearningSpeed) / l.eat.getV(clock)

		    # Pull To Zero ptz PTZ

		    linkTD += (0.0 - l.qValue) * self.qLearningSpeed * 0.1	# 1/10th pull to zero

		    node.linkVar.updateAvg(clock, linkTD ** 2)		# track update varriance as measure of noise

		    l.qValue += linkTD

		#
		# Normalize link q values to a zero average.
		# Not very important for behavior but really helps see how the system
		# works when graphing q values.
		#

		qSum = 0.0

		for i in range(numLinks):
		    qSum += node.links[i].qValue

		for i in range(numLinks):
		    node.links[i].qValue -= qSum / numLinks



    def secondaryReinforcement(self, clock, doDebug=False):
	# Still undecided how to do this
	# But a zero reward doesn't change the RPS which is what the
	# the net optimizes for, so this works as a way to stimulate
	# a network which is not otherwise getting enough rewards.
	# But, there might be a better way to do Secondary Reinforcement.

	self.reward(clock, 0.0, doDebug)


class Histogram:
    # Sideways ascii historgram printer
    def __init__(self, rows, width=15, name=None, fixedScale=None):
    	self.rows = rows
	self.width = width		# Number of characters wide for bars (approximately)
	self.name = name
	self.histScale = width		# Current dynamic scaling factor for historgram
	self.histScaleMSE = 1.0		# Mean Squared Error of histScale
	self.resetCounts()
	self.lastPrintRow = rows+1
	self.fixedScale = fixedScale	# set to the max value you want to plot into the self.width

    def setFixedScale(self, fixedScale):
    	self.fixedScale = fixedScale	# setting to a value turns off auto scaling

    def resetCounts(self):
        self.counts = [0]*self.rows

    def printBarGraph(self):
	# print entire bar graph with numbers
	if self.name:
	    print self.name
    	for i in range(self.rows):
	    print "%2d " % i,
	    if self.counts[i] == 0:
	    	print "    ."
	    else:
		print "%5d " % self.counts[i],
		self.printBar(i)
d149 1
a149 1701

    def printBar(self, row):
	# Fancy auto-rescale code below that shifts scale slowly
	# so that repating displays of graph is not making quick drastic
	# scale changes on every display.

	if row <= self.lastPrintRow:	# rescale before printing first row of set
	    # External print routine might skip some rows so we have
	    # do the fancy lastPrintRow test to see if the print is starting over
	    maxRow = max(max(self.counts), 1)
	    if maxRow > self.histScale * 2:
		# fast rescale when way off
		self.histScale = maxRow
	    speed = 0.005
	    speedFactor = 1 + (speed * math.sqrt(self.histScaleMSE) / self.histScale)
	    if maxRow > self.histScale:
		self.histScale *= speedFactor
	    else:
		self.histScale /= speedFactor

	    self.histScaleMSE += ((self.histScale - maxRow) ** 2 - self.histScaleMSE) * 0.1

	self.lastPrintRow = row

	if self.fixedScale is not None:
	    scale = self.fixedScale
	else:
	    scale = self.histScale

	w = min(scale, self.width)
	n = int(1 + ((self.counts[row]-1) * w) / scale)

	for r in range(n):
	    sys.stdout.write("=")

class Process:
    def __init__(self, simulator, name, gap=None, frequency=None, triggerMethod=None, realTime=False, realTimeFrequency=None):
	# implements a repeating cycle of a fixed
	# call every "gap" clock ticks.  Subclasses can overide getNextClock()
	# to create more complex behaviors
	# Real time Frequency causes the process to dynamically adjust
	# it's simulation time frequencey to produce trigger events that happen
	# syncronized to the realTimeFrequency.  So setting to 1.0 causes the event
	# to trigger approxomatly once a second in real time no matter how fast or slow
	# the sumulation is running. Used for display updates or the like.
    	self.simulator = simulator
	self.name = name
	self.nextClock = 0.0
	self.gap = None
	self.setGap(gap)
	self.setFrequency(frequency)
	if self.gap is None:
	    self.setFrequency(1.0);		# default to 1 second rate if gap or frequency not specified
	self.triggerMethod = triggerMethod
	self.realTime = realTime		# process triggers sync to real time
	self.realTimeFrequency = realTimeFrequency
	self.lastTriggerRealTime = time.time()
	self.lastTriggerSimulationTime = 0.0

	self.simulator.addProcess(self)		# Add myself to the simulator


    def setRealTime(self, realTime):
	# boolean
    	self.realTime = realTime

    def isRealTime(self):
    	return self.realTime

    def getName(self):
	# can be overriden to implment more complex name
    	return self.name

    def getNextClock(self):
	# Children can overide to implement a more complex
	# version of this.
	# once getNextClock() returns a future
	# time, it's not allowed to change it because
	# we could be on the Simulation event queue for that time.
	# If it needs to change, see how setGap() works.
	# So, Only generate a new time if self.nextClock is in the past.
	# The value returned must be greater then current time. (simulator.getClock())

	now = self.simulator.getClock()
	while self.nextClock <= now:
	    self.nextClock += self.getGap()

	return self.nextClock

    def setGap(self, gap, doDebug=False):
	# Sets the frequency gap as the number of clock ticks between each pulse.
	# if this is changed in middle of a run, we need to notifiy the simulator
	# that things have changed. 
	#
	# if gap is None, we do nothing
	# gap can be a an integer or real, but must be postive greater than zero

	if gap is None:
	    return
	if gap <= 0.0:
	    raise Exception("gap must be postive. gap is: %f" % gap);
	if gap == self.gap:
	    # nothing changed, nothing to do
	    return

	if self.gap is None:
	    self.gap = gap
	    return

	# Gap was already set, must do complex update to change gap while
	# The process is(or might be) running.
	# We figure out what % of time is left in the current cycle, and then
	# calculate newNextClock based on applying that same percent, to the new gap.
	# This allows for inteligent frequency updates in the middle of cycles.

	currentNextClock = self.getNextClock()
	now = self.simulator.getClock()
	newNextClock = now + gap * ((currentNextClock - now) / self.gap)

	self.gap = gap
    
	if newNextClock != currentNextClock:
	    # must update location in event queue
	    self.nextClock = newNextClock
	    self.simulator.updateProcess(self, doDebug=doDebug)

	return


    def setFrequency(self, frequency, doDebug=False):
	# Clock ticks are seconds and frequency is in hz
	if doDebug:
	    print "set frequence of", self.name, "to", frequency
    	if frequency is None or frequency == 0.0:
	    return
	self.setGap(1.0/frequency, doDebug)

    def getGap(self):
    	return self.gap

    def getFrequency(self):
	return 1.0/self.getGap()

    def trigger(self, clock):
	# This is the method called by the simulation
	# to run this process for each clock tick it's been
	# registered to run for.
	# Can be overriden by subclasses or the self.triggerMethod callback

	if self.realTimeFrequency:
	    # Dynamically adjust simulation time trigger rate
	    # to make these events happen neart the real time rate.
	    now = time.time()
	    realSeconds = now - self.lastTriggerRealTime
	    self.lastTriggerRealTime = now
	    self.lastTriggerSimulationTime = clock
	    oldGap = self.getGap()
	    newGapTarget = oldGap / (realSeconds * self.realTimeFrequency)
	    newGap = oldGap + (newGapTarget - oldGap) * 0.5
	    self.setGap(newGap)

	if self.triggerMethod:
	    return self.triggerMethod(clock)

    	raise NotImplementedError

    def delProcess(self):
    	# Delete ourselves from the simulator event queue
	# Could be called by tigger to turn us off.
	self.simulator.delProcess(self)


class PulseGenerator(Process):
    """ A Pulse generator for run time environment testing
    	Sends pulses into net at a fixed rate
    """
    def __init__(self, simulator, name, net, row, gap=None, frequency=None, resultMethod=None):
        self.net = net
	self.row = row
	self.resultMethod = resultMethod
	self.rowHistogram = Histogram(self.net.rows, name=name)
	Process.__init__(self, simulator, name, gap, frequency)

    def resetCounts(self):
        self.rowHistogram.resetCounts()

    def trigger(self, clock):
	# Called by system when next clock event happens

    	out = self.net.sort(self.row, clock)
	self.rowHistogram.counts[out] += 1

	if self.resultMethod:
	    return self.resultMethod(self, out, clock)		# send result to resultMethod

class RandomPulseGenerator(PulseGenerator):
    # Same as pulse generator, except our frequency changes randomly.
    def __init__(self, simulator, name, net, row, gap=None, frequency=None, resultMethod=None, medianGap=None, sdGap=None):
	self.medianGap = medianGap
	self.sdGap = sdGap

    	PulseGenerator.__init__(self, simulator, name, net, row, gap=gap, frequency=frequency, resultMethod=resultMethod)

	if self.medianGap is None:
	    self.medianGap = self.getGap()

	if self.sdGap is None:
	    self.sdGap = self.medianGap / 30.0

    def trigger(self, clock):
    	PulseGenerator.trigger(self, clock)

	gap = np.random.normal(self.medianGap, self.sdGap)

	if gap > 0.0:
	    self.setGap(gap)



class Simulator:
    """ Run a simulation to test network
    	This class implments the main clock scheduling loop
	and calls out to multiple Process objects at the times they regeister for.
    """
    def __init__(self):
	self.processHeap = []	# Heap of [clock, process] lists
	self.processMap = {}	# map for tracking entries in processHeap by process
	self.clock = 0		# simulation clock, increments by one
	self.startTime = time.time()	# real clock time start time
	self.REMOVED = "dead process"
	self.realTime = False
	self.speed = 1		# real time to simulation time speed up (10x)

    def addProcess(self, process):
	# add if NOT already in queue -- do not update if already in quque
	if process in self.processMap:
	    return
    	entry = [process.getNextClock(), process]
    	heapq.heappush(self.processHeap, entry)
	self.processMap[process] = entry

    def updateProcess(self, process, doDebug=False):
	# Delete process if already in queue, and re-add.
	# Used when the nextClock value has changed and the process needs a new location
	# in the event queue.
	if process in self.processMap:
	    entry = self.processMap[process]
	    if entry[0] == process.getNextClock():
	    	# No update needed, nextClock is the same!
		return
	    # remove first -- used for updating the process when needed
	    self.delProcess(process)
	self.addProcess(process)
	if doDebug:
		print "in update Process -------------"
		print "processHeap is", self.processHeap
		print "map is", self.processMap

    def delProcess(self, process):
    	# Remove process from processHeap by marking it REMOVED.
	# Removing it is too expensive.
	if process in self.processMap:
	    map = self.processMap[process]
	    map[-1] = self.REMOVED
	    del self.processMap[process]

    def popProcess(self, process=None):
	while True:
	    nextTick, proc = heapq.heappop(self.processHeap)
	    if proc == self.REMOVED:
	    	continue
	    break
	del self.processMap[proc]
	return nextTick, proc

    def getClock(self):
	return self.clock

    def reward(self, reward, doDebug=False):
	# Just a pass-though method
    	self.net.reward(self.clock, reward, doDebug)

    def run(self, realTime=False, speed=1.0):
	# the main run loop 
	# realTime syncs the siution to the system clock
	# speed is used as speed up factor for real time.
	# speed=10 runs simuaiton at 10x relative to real time

	if len(self.processHeap) == 0:
	    print "No Processes to Run!"
	    return  # nothing to do

	self.startTime = time.time()	# real time in seconds
	self.realTime = realTime
	self.speed = speed

	while True:
	    # Get next event
	    nextTick,proc = self.popProcess()
	    # print "clock is ", self.clock, "popped clock:", nextTick, "proc:", proc.getName()
	    #  advance clock to event
	    if nextTick < self.clock:
		# print "clock is", self.clock, " nexttixk is", nextTick
	    	raise Exception("error, clock goes backwards!")
	    self.clock = nextTick		# advance time!

	    if realTime or proc.isRealTime():
		 # run simulationin real time by sleeping as needed between simulation events 
		 # do for all events, or just the ones that declare themselves as realTime
		 runTime = (time.time() - self.startTime) * speed
		 if self.clock > runTime:
		    time.sleep((self.clock - runTime) / speed)

	    # print self.clock, "call trigger", proc.name
	    r = proc.trigger(self.clock)
	    # Note, trigger might have used updateProcess() to put process back in map with a new updated
	    # clock location, we when we add it back, it won't get added if it is already in the queue.
	    if r != "remove":
		# Process requests being removed from queue by
		# returning "remove"
		self.addProcess(proc)

    def displayHeader(self):
	crtClearAndHome()

	print "XNET", time.ctime(self.startTime),

	seconds = time.time() - self.startTime
	hours = int(seconds / 3600.0)
	seconds -= hours * 3600.0
	minutes = int(seconds / 60.0);
	seconds = int(seconds - minutes * 60.0)
	print " RunTime: %d:%02d:%02d" % (hours, minutes, seconds),

	if self.realTime:
	    print " Real-Time Simulation speed=%dX" % self.speed,

	if len(sys.argv) > 1:
	    # Command line message goes next
	    print " [",
	    for i in range(len(sys.argv)-1):
	    	print sys.argv[i+1],
	    print "]",

	print

class SimpleTest(Simulator):
    def __init__(self):
    	Simulator.__init__(self)

	# set up the stuff I need for this simulation
	self.name = "simple test object"
	self.net = Network(6, 2, "SimpleTest p1 +1 out4, p2 0 for out4",
		forceExploration=0.01,	# 5% 
		halfLife=10.0,
		qLearningSpeed=0.00001,
		bLearningSpeed=0.00001,
		# sLevel=0.0001,
		sdRatio=1000.0,
		wLearningSpeed=0.00001,
		wireBinary=False,
		wireFanOut=6
	    )
	self.p1 = PulseGenerator(self, "P1", self.net, 2, gap=1.3, resultMethod=self.pulseOutput)
	self.p2 = PulseGenerator(self, "P2", self.net, 4, gap=1, resultMethod=self.pulseOutput)
	# Process(self, "freq", gap=20.0, triggerMethod=self.changeP1Freq)
	# Process(self, "freq", gap=11.0, triggerMethod=self.changeP2Freq)
	Process(self, "disp", triggerMethod=self.displayTrigger, realTimeFrequency=1)
	self.doDebugOnceP1 = False
	self.doDebugOnceP2 = False

	self.plotter = PlotRPS(self, self.net, gap=100)
	self.Plotter2 = PlotLinkQ(self, self.net, self.net.nodes[self.p1.row][0], gap=100)
	self.Plotter2 = PlotLinkQ(self, self.net, self.net.nodes[self.p2.row][0], gap=100)

    def pulseOutput(self, sender, out, clock):
	# inverted Negative learning version of simple test!
	# where the "Good" answer is a negative number!
	if sender == self.p1:
	    if out == 4:
		self.reward(+1, doDebug=self.doDebugOnceP1)
	    else:
		self.reward(-1, doDebug=self.doDebugOnceP1)

	if sender == self.p2:
	    if out == 4:
		self.reward(-1, doDebug=self.doDebugOnceP1)
	    else:
		self.reward(+1, doDebug=self.doDebugOnceP1)

	return

	if sender == self.p1:
	    if out == 4:
		self.reward(1, doDebug=self.doDebugOnceP1)
	    else:
		self.reward(-1, doDebug=self.doDebugOnceP1)

	if sender == self.p2:
	    if out == 4:
		self.reward(-1, doDebug=self.doDebugOnceP1)
	    else:
		self.reward(1, doDebug=self.doDebugOnceP1)

	return

	if out == 4:
	    if sender == self.p1:
		if self.doDebugOnceP1:
		    print sender.name, "sorts to output", out
		self.reward(1, doDebug=self.doDebugOnceP1)
		if self.doDebugOnceP1:
		    # self.doDebugOnceP2 = True
		    self.doDebugOnceP1 = False
	    else:
		if True:
		    if self.doDebugOnceP2:
			print sender.name, "sorts to output", out
		    self.reward(-1, doDebug=self.doDebugOnceP2)
		    self.doDebugOnceP2 = False
	# if out == 7 and sender == self.p2:
	#    self.reward(1)

    def changeP1Freq(self, clock):
	# toggle p1 between 100 and 500
	self.p1.setGap(.100 + .500 - self.p1.getGap())
	# self.p1.setFrequency(max(1.0, random.gauss(10.0,5.0)), doDebug=False)

    def changeP2Freq(self, clock):
	# toggle p2 between 0.100 and 0.500
	self.p2.setGap(0.100 + 0.500 - self.p2.getGap())

    def displayTrigger(self, clock):
	#self.doDebugOnceP1 = True
	self.reward(0)

	if clock < 1:
	    # reset counts even if we don't display, to keep first display
	    # from having huge counts and messing up auto-scaling of histograms
	    self.net.resetCounts()
	    return

	self.displayHeader()

	print "  p1 freq:", "%4.1f " % self.p1.getFrequency(),
	self.printHist(int(self.p1.getFrequency()))

	print "  p2 freq:", "%4.1f " % self.p2.getFrequency(),
	self.printHist(int(self.p2.getFrequency()))

	print

	self.net.show(now=clock, doQ=False)
	self.net.resetCounts()

	self.net.showNode(self.p1.row, 0)
	self.net.showNode(self.p2.row, 0)

	c1 = float(self.p1.rowHistogram.counts[4])
	c2 = float(self.p2.rowHistogram.counts[4])
	if (c1+c2) > 0:
	    print "p1 percent for output 4 is: %6.2f" % (100.0*c1/(c1+c2))
	else:
	    print "p1 percent for output 4 is: %6.2f" % 0

	self.p1.rowHistogram.printBarGraph()
	self.p1.resetCounts()
	self.p2.rowHistogram.printBarGraph()
	self.p2.resetCounts()
	#time.sleep(0.2)

    def printHist(self, n):
    	for i in range(n):
	    sys.stdout.write("=")

class HallTest(Simulator):
    def __init__(self):
    	Simulator.__init__(self)

	self.net = Network(7, 5, "Hall Test",
		halfLife=5.0,
		qLearningSpeed=0.000001,
		bLearningSpeed=0.0001,
		# sLevel=0.0000001,
		sdRatio=1000.0,
		wLearningSpeed=0.00001,
		wireFanOut=3
		)
	self.foodLeft = PulseGenerator(self, "FL", self.net, 1, resultMethod=self.pulseOutput)
	self.foodRight = PulseGenerator(self, "FR", self.net, 5, resultMethod=self.pulseOutput)
	# self.toggleFoodIsLeftProcess = Process(self, "Toggle", gap=10, triggerMethod=self.toggleFoodIsLeft)
	Process(self, "disp", triggerMethod=self.displayTrigger, realTime=False, realTimeFrequency=2)
	#
	# World State
	#
	self.foodIsLeft = True
	self.setFoodIsLeft(True)
	self.width = 50				# length of hall (0 to width-1)
	self.beasty = int(self.width/2.0)	# Location of beasty - real number
	self.foodCount = 0
	self.lastFoodClock = 0
	self.lastSecondsPerFood = None
	self.avgSecondsPerFood = None
	self.doDebug0Once = False
	self.doDebug1Once = False
	self.doDebug5Once = False
	self.oldBeasty = self.beasty
	self.oldfoodIsLeft = self.foodIsLeft

	self.plotter = PlotRPS(self, self.net, gap=10)
	self.Plotter2 = PlotLinkQ(self, self.net, self.net.nodes[self.foodLeft.row][0], gap=10)
	self.Plotter2 = PlotLinkQ(self, self.net, self.net.nodes[self.foodRight.row][0], gap=10)

    def pulseOutput(self, sender, out, clock):
	# print "pulse out sender is", sender.name, "out is:", out
	moved = False
	self.oldBeasty = self.beasty
	self.oldfoodIsLeft = self.foodIsLeft
	middleRow = int(self.net.rows/2)
	# if out < middleRow: # move left
	if out == 6: # move left
	    self.beasty -= 1.0	# Move to left
	    moved = True
	    # if False: # reward movement 
	    if randomPercent(1):
		if self.foodIsLeft:
		    self.hallReward(1)
		else:
		    self.hallReward(0)
	# elif out > middleRow: # move right
	elif out == 2: # move right
	    self.beasty += 1.0	# Move to right
	    moved = True
	    # if False: # reward movement 
	    if randomPercent(1):
		if self.foodIsLeft:
		    self.hallReward(0)
		else:
		    self.hallReward(1)

	if self.beasty <= 0.0:
	    self.beasty = 0.0	# hit wall
	    if self.foodIsLeft:
		self.eat()
		self.setFoodIsLeft(False)
	if self.beasty >= self.width-1:
	    self.beasty = min(self.beasty, self.width-1) # can't walk through walls
	    if not self.foodIsLeft:
		self.eat()
		self.setFoodIsLeft(True)

	if moved:
	    self.displayUpdateHall()
	    # if clock / 3600 > 25:
		# time.sleep(0.001)

	if randomPercent(1):
	    self.hallReward(0)

    def hallReward(self, r):
	self.reward(r, doDebug=self.doDebug0Once)
	self.doDebug0Once = False

    def eat(self):
	self.hallReward(1)
	self.foodCount += 1
	now = self.getClock()
	self.lastSecondsPerFood = now - self.lastFoodClock
	self.lastFoodClock = now
	speed = 0.001
	if self.avgSecondsPerFood is None:
	    self.avgSecondsPerFood = self.lastSecondsPerFood	# first time only
	if self.foodCount < 10:
	    # average all from the start for the first 10
	    self.avgSecondsPerFood = now / self.foodCount
	else:
	    # switch to running average
	    self.avgSecondsPerFood += (self.lastSecondsPerFood - self.avgSecondsPerFood) * speed

    def toggleFoodIsLeft(self, clock):
    	self.setFoodIsLeft(not self.foodIsLeft)

    def setFoodIsLeft(self, foodIsLeft):
    	if foodIsLeft:
	    self.foodLeft.setFrequency(10)
	    self.foodRight.setFrequency(1)
	else:
	    self.foodLeft.setFrequency(1)
	    self.foodRight.setFrequency(10)
	self.foodIsLeft = foodIsLeft


    def displayTrigger(self, clock):
	# self.net.secondaryReinforcement(clock, doDebug=True) # periodic backprop updates
	# self.reward(random.random()*.01)
	#self.doDebug0Once = True
	#self.doDebug1Once = True

	if clock < 1:
	    # reset counts even if we don't display, to keep first display
	    # from having huge counts and messing up auto-scaling of histograms
	    self.net.resetCounts()
	    return

	self.displayHeader()

	print

	print "  foodLeft freq:", "%4.1f " % self.foodLeft.getFrequency(),
	self.printHist(int(self.foodLeft.getFrequency()))
	print "  foodRight freq:", "%4.1f " % self.foodRight.getFrequency(),
	self.printHist(int(self.foodRight.getFrequency()))
	print

	print

	self.net.show(now=clock, doB=False, doW=False, doQ=False)
	self.net.resetCounts()
	# self.foodLeft.rowHistogram.printBarGraph()
	self.foodLeft.resetCounts()
	# self.foodRight.rowHistogram.printBarGraph()
	self.foodRight.resetCounts()

	print

	self.displayHall()

	print

	self.net.showNode(self.foodLeft.row, 0)
	self.net.showNode(self.foodRight.row, 0)

    def displayHall(self):
	sys.stdout.write("+")
	for i in range(self.width):
	    sys.stdout.write("-")
	sys.stdout.write("+")
	print
	sys.stdout.write("|")
	for i in range(self.width):
	    if (i == 0 and self.foodIsLeft) or (i == self.width - 1 and not self.foodIsLeft):
		sys.stdout.write(":")
		continue
	    if i == int(self.beasty):
		sys.stdout.write("B")
		continue
	    sys.stdout.write(".")
	sys.stdout.write("|")
	print
	sys.stdout.write("+")
	for i in range(self.width):
	    sys.stdout.write("-")
	sys.stdout.write("+")
	print
	print "Beasty location: %2.0f" % self.beasty,
	print "  Food Count:", self.foodCount,
	if self.avgSecondsPerFood:
	    print "  Avg SPF: %.1f" % self.avgSecondsPerFood,
	    print "  Last SPF: %.1f" % self.lastSecondsPerFood,
	print "  Seconds: %d" % (self.getClock() - self.lastFoodClock)
	print

    def displayUpdateHall(self):
	beastyCRTrow = 16

	if self.beasty != self.oldBeasty:
	    crtGOTO(beastyCRTrow, self.oldBeasty+2)
	    sys.stdout.write(".")

	    crtGOTO(beastyCRTrow, self.beasty+2)
	    sys.stdout.write("B")

	if self.oldfoodIsLeft != self.foodIsLeft:
	    if self.foodIsLeft:
	    	col = 1
	    else:
	    	col = self.width+1
	    crtGOTO(beastyCRTrow, col)
	    sys.stdout.write(":")

	crtGOTO(beastyCRTrow+4, 0)
	sys.stdout.flush()
	#time.sleep(0.01)

    def printHist(self, n):
    	for i in range(n):
	    sys.stdout.write("=")

class TwoNodeTest(Simulator):
    # Was hallTest, but then cutting down to two nodes revealed issues
    # so I'm ripping out all the HallTest specific code and turning it
    # to a simple two node test case I can come back to when I need to.
    def __init__(self):

    	Simulator.__init__(self)

	self.net = Network(7, 2, "Two Node Test",
	    halfLife=20.0,
	    qLearningSpeed=.00001,
	    bLearningSpeed=.0001,
	    sdRatio=1000.0,
	    # sLevel=0.00001,
	    wLearningSpeed=.0001
	)
	self.p1 = PulseGenerator(self, "p1", self.net, 1, frequency=1.01, resultMethod=self.pulseOutput)
	self.p2 = PulseGenerator(self, "p2", self.net, 5, frequency=0.99, resultMethod=self.pulseOutput)
	Process(self, "disp", triggerMethod=self.displayTrigger, realTime=False, realTimeFrequency=2)

	self.doDebug0Once = True
	self.doDebug1Once = True

	# jump start learning -- wire his brain

	if False:
	    self.net.nodes[1][0].qValue = 5.49
	    self.net.nodes[5][0].qValue = 5.49

	    self.net.nodes[0][1].qValue = 5.49
	    self.net.nodes[1][1].qValue = 4.489
	    self.net.nodes[2][1].qValue = 5.49

	    self.net.nodes[4][1].qValue = 4.489
	    self.net.nodes[5][1].qValue = 5.49
	    self.net.nodes[6][1].qValue = 4.489

	self.plotter = PlotRPS(self, self.net, gap=1000)
	self.Plotter2 = PlotLinkQ(self, self.net, self.net.nodes[1][0], gap=1000)
	self.Plotter3 = PlotLinkQ(self, self.net, self.net.nodes[5][0], gap=1000)

    def pulseOutput(self, sender, out, clock):
	# I thought these would be the same, but due
	# to the fact that most frequent one is phase
	# shifted to be closer to the presnet, it
	# ends up with higher actual values in
	# the system.  By a lot.
	# No, not true.  Sometimes the high frequency
	# will be higher, sometimes the low frequency.
	# It depends on the the frequency relative
	# to the halfLife.  It's complicated.
    	if True and out == 0:
	    if randomPercent(40):
		# 0.452 RPS
		self.reward(1, doDebug=self.doDebug0Once)
		self.doDebug0Once = False
    	elif False and out == 1:
	    if randomPercent(20):
		# 0.523 RPS
		self.reward(2, doDebug=self.doDebug0Once)
		self.doDebug0Once = False
    	elif False and out == 2:
	    if randomPercent(10):
		# 0.659 RPS
		self.reward(4, doDebug=self.doDebug0Once)
		self.doDebug0Once = False

	# if randomPercent(1):
	    # self.reward(0)

	return

	# randomPercent = 0.01
    	if out == 1:
	    self.reward(-1+random.random()*randomPercent, doDebug=self.doDebug0Once)
	    self.doDebug0Once = False
    	elif out == 5:
	    self.reward(1+random.random()*randomPercent, doDebug=self.doDebug1Once)
	    self.doDebug1Once = False
	else:
	    self.reward(0)

    def displayTrigger(self, clock):
	self.doDebug0Once = True
	self.doDebug1Once = True

	if clock < 1:
	    # reset counts even if we don't display, to keep first display
	    # from having huge counts and messing up auto-scaling of histograms
	    self.net.resetCounts()
	    return

	self.displayHeader()

	print

	self.net.show(now=clock)

	self.net.showNode(1, 0)
	self.net.showNode(5, 0)

	self.net.resetCounts()


class OneNodeTest(Simulator):
    def __init__(self):
    	Simulator.__init__(self)

	#
	# Special test for this problem of qValues converging on almost identical values
	# when they get too close the network sees them as "equal" even though the
	# two options are very very different in what they do (-1 reward vs +1 reward).
	# This happens becuase the qValues converge on what the current policy is producing
	# and the bad option, is only a tiny little bit worse IF the policy is no using
	# it. So as it's being explored, it looks better and better becuae of the policy.
	# So when it converges so close to the "good" option, the whole game colapses
	# and the system starts using as if it were just as good as the good.
	#
	# So, set up one network, 3 outputs, up is -1, down is +1, middle is no rewards.
	#

	self.net = Network(3, 2, "Colapse Test",
	    qLearningSpeed=0.000001,
	    bLearningSpeed=0.000001,
	            # sLevel=0.000001,
	    sdRatio=1000.0,
	    wLearningSpeed=0.0001,
	    forceExploration=0.01,
	    wireFanOut=3,
	    halfLife=10.0)

	self.pulseProc = PulseGenerator(self, "", self.net, 1, frequency=1, resultMethod=self.pulseOutput)

	self.displayProc = Process(self, "disp", triggerMethod=self.displayTrigger, realTime=False, realTimeFrequency=2)

	self.doDebugOnce = False

	self.plotter = PlotRPS(self, self.net, gap=1000)
	self.Plotter2 = PlotLinkQ(self, self.net, self.net.nodes[1][0], gap=1000)

	if False:
	    # Hack in starting b values
	    self.net.nodes[1][0].links[0].b = 0.0
	    self.net.nodes[1][0].links[0].w = 0.01
	    self.net.nodes[1][0].links[0].qValue = .9622
	    self.net.nodes[1][0].links[1].b = 0.0
	    self.net.nodes[1][0].links[1].w = 0.01
	    self.net.nodes[1][0].links[1].qValue = .9670
	    self.net.nodes[1][0].links[2].b = 1000000.0 
	    self.net.nodes[1][0].links[2].w = 0.98
	    self.net.nodes[1][0].links[2].qValue = .9711

	    # self.net.nodes[0][1].qValue = 8.0
	    # self.net.nodes[1][1].qValue = 8.0
	    # self.net.nodes[2][1].qValue = 8.0

    def pulseOutput(self, sender, out, clock):
	if False and out == 3:
	    self.reward(1)

	if True:
	    c = [-1.0, +1.0, +1.0]
	    c = [+1.0, +1.0, +1.0]
	    c = [+1.0, +1.0, +1.00001]
	    # zzz
	    c = [1000.0, 1000000.0, 1001000.0]
	    c = [-1, None, +1]
	    self.net.name = "OneNodeTest rewards: [%s %s %s]" % (c[0], c[1], c[2])
	    r = c[out]
	    if r is not None:
		self.reward(r+random.random()*0.001, doDebug=self.doDebugOnce)
		self.doDebugOnce = False
	    if randomPercent(1):
		self.reward(0)	# 0 reward 1% of the time when no other reward


    def displayTrigger(self, clock):
	# self.net.secondaryReinforcement(clock, doDebug=True) # periodic backprop updates
	self.doDebugOnce = True

	if clock < 1:
	    # reset counts even if we don't display, to keep first display
	    # from having huge counts and messing up auto-scaling of histograms
	    self.net.resetCounts()
	    return

	self.displayHeader()

	print

	self.net.show(now=clock)

	print

	self.net.showNode(1, 0)

	self.net.resetCounts()

class TwoNodeOverlapTest(Simulator):
    # two nodes with one shared node overlaping
    def __init__(self):

    	Simulator.__init__(self)

	self.net = Network(8, 12, "Two Node Overlap Test",
	    halfLife=250.0,
	    qValue=1.0,
	    qLearningSpeed=.00001,
	    bLearningSpeed=.00001,
	    wLearningSpeed=.0001,
	    wireFanOut=5,
	    wireBinary=False
	)

	self.net.rowHistogram.setFixedScale(200)
	self.p0 = None
	self.p0 = PulseGenerator(self, "p0", self.net, 0, frequency=1.0, resultMethod=self.pulseOutput)
	self.p1 = PulseGenerator(self, "p1", self.net, 1, frequency=1.0, resultMethod=self.pulseOutput)
	self.p2 = PulseGenerator(self, "p2", self.net, 2, frequency=1.0, resultMethod=self.pulseOutput)
	self.p3 = None
	self.p3 = PulseGenerator(self, "p3", self.net, 3, frequency=1.0, resultMethod=self.pulseOutput)
	# self.p4 = RandomPulseGenerator(self, "p4", self.net, 4, frequency=2.0, resultMethod=self.pulseOutput, sdGap=1.0)
	self.p4 = None
	Process(self, "freq", gap=3000.0, triggerMethod=self.changeFreq)
	Process(self, "disp", triggerMethod=self.displayTrigger, realTime=False, gap=100.0)

	self.pHistogram = Histogram(5, width=50, fixedScale=3)	# to track and display p1 and p2 frequency
	self.updatePHistogram()

	self.doDebug0Once = True
	self.doDebug1Once = True

	self.freqTable = []
	self.freqTable.append((1.0, 1.0))
	self.freqTable.append((1.0, 2.0))
	self.freqTable.append((1.0, 3.0))
	self.freqTable.append((2.0, 3.0))
	self.freqTable.append((3.0, 3.0))
	self.freqTable.append((3.0, 2.0))
	self.freqTable.append((3.0, 1.0))
	self.freqTable.append((2.0, 1.0))
	self.freqTable.append((1.0, 1.0))
	self.freqTable.append((2.0, 2.0))
	self.freqTable.append((3.0, 3.0))
	self.freqTable.append((2.0, 2.0))

	if True: # Binary counting
	    self.freqTable = []
	    l = 1.0
	    h = 2.0
	    self.freqTable.append((l, l, l)) # Binary count 0 to 3
	    self.freqTable.append((l, h, l))
	    self.freqTable.append((h, l, l))
	    self.freqTable.append((h, h, l))
	    self.freqTable.append((l, l, h)) # Binary count 0 to 3
	    self.freqTable.append((l, h, h))
	    self.freqTable.append((h, l, h))
	    self.freqTable.append((h, h, h))
	    self.freqTotal = 3*h + l + 1		# A number greater than the sum of the max frequencies
	    self.freqTableIndex = 0

	if False: # Binary counting
	    self.freqTable = []
	    l = 0.1
	    h = 2.0
	    self.freqTable.append((l, l, l)) # Binary count 0 to 3
	    self.freqTable.append((l, l, l)) # Binary count 0 to 3
	    self.freqTable.append((l, h, l))
	    self.freqTable.append((l, h, l))
	    self.freqTable.append((h, l, l))
	    self.freqTable.append((h, l, l))
	    self.freqTable.append((h, h, l))
	    self.freqTable.append((h, h, l))
	    self.freqTable.append((l, l, h)) # Binary count 0 to 3
	    self.freqTable.append((l, l, h)) # Binary count 0 to 3
	    self.freqTable.append((l, h, h))
	    self.freqTable.append((l, h, h))
	    self.freqTable.append((h, l, h))
	    self.freqTable.append((h, l, h))
	    self.freqTable.append((h, h, h))
	    self.freqTable.append((h, h, h))
	    self.freqTotal = 3*h + l			# A number greater than the sum of the max frequencies
	    self.freqTableIndex = 0

	if False: # Three sequential pulses
	    self.freqTable = []

	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))

	    self.freqTable.append((5.0, 0.1, 0.1))
	    self.freqTable.append((5.0, 0.1, 0.1))
	    self.freqTable.append((5.0, 0.1, 0.1))
	    self.freqTable.append((5.0, 0.1, 0.1))
	    self.freqTable.append((5.0, 0.1, 0.1))
	    self.freqTable.append((5.0, 0.1, 0.1))

	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))

	    self.freqTotal = None			# A number greater than the sum of the max frequencies
	    self.freqTableIndex = 0

	if False: # Three pulses but one overlaps the other two
	    self.freqTable = []

	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))
	    self.freqTable.append((0.1, 5.0, 0.1))

	    self.freqTable.append((5.1, 5.0, 0.1))
	    self.freqTable.append((5.1, 5.0, 0.1))
	    self.freqTable.append((5.1, 0.1, 0.1))
	    self.freqTable.append((5.1, 0.1, 5.0))
	    self.freqTable.append((5.1, 0.1, 5.0))

	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))
	    self.freqTable.append((0.1, 0.1, 5.0))

	    self.freqTotal = None			# A number greater than the sum of the max frequencies
	    self.freqTableIndex = 0

	self.changeFreq(self.getClock())


	self.counts = [0]*self.net.rows
	self.oldCounts = []		# array of array of saved counts
	self.nextCountResetHour = 50
	self.nextCountResetHourInc = 50

	if False:
	    self.net.nodes[1][0].qValue = 5.49

	self.doWReduce = True

	if self.doWReduce:
	    self.nextWReduceHour = 10 # start reducing wLearning at this hour
	    self.nextWReduceHourInc = 10 # how often after the first
	    self.wReduceFactor = 0.9 # reduction factor
	    self.wReduceMinW = 0.00001   		# don't reduce below this
	    self.wReduceMinW = 0.0000001		# don't reduce below this

	self.plotGap = 10
	self.plotter0 = PlotCol(self, self.net, 0, gap=self.plotGap)
	if self.net.cols > 2:
	    self.plotter1 = PlotCol(self, self.net, 1, gap=self.plotGap)
	if self.net.cols > 3:
	    self.plotter2 = PlotCol(self, self.net, 2, gap=self.plotGap)
	self.plotter3 = PlotCol(self, self.net, self.net.cols-1, gap=self.plotGap)

	self.plotterRPS = PlotRPS(self, self.net)

    def changeFreq(self, clock):

	self.freqTableIndex = (self.freqTableIndex + 1) % len(self.freqTable)

	f1,f2,f3 = self.freqTable[self.freqTableIndex]

	percentRandom = 0.01 # 1 percent random frequency adjust factor
	percentRandom = 0.00 # no random adjust

	self.p1.setFrequency(f1*(1.0 + (random.random()-0.5)*percentRandom*2.0))
	self.p2.setFrequency(f2*(1.0 + (random.random()-0.5)*percentRandom*2.0))
	if self.p3 is not None:
	    self.p3.setFrequency(f3*(1.0 + (random.random()-0.5)*percentRandom*2.0))

	if True and self.freqTotal is not None:
	    f = self.freqTotal
	    if self.p1 is not None:
	    	f -= self.p1.getFrequency()
	    if self.p2 is not None:
	    	f -= self.p2.getFrequency()
	    if self.p3 is not None:
	    	f -= self.p3.getFrequency()

	    if self.p0 is not None:
		self.p0.setFrequency(f)

	self.updatePHistogram()

	return

	if random.random() > .5:
	    self.p1.setFrequency(1.0 + 3.0 - self.p1.getFrequency())
	    if random.random() > .5:
		self.p2.setFrequency(1.0 + 3.0 - self.p2.getFrequency())
	else:
	    self.p2.setFrequency(1.0 + 3.0 - self.p2.getFrequency())

    def updatePHistogram(self):
	if self.p0 is not None:
	    self.pHistogram.counts[0] = self.p0.getFrequency() * 10
	self.pHistogram.counts[1] = self.p1.getFrequency() * 10
	self.pHistogram.counts[2] = self.p2.getFrequency() * 10
	if self.p3 is not None:
	    self.pHistogram.counts[3] = self.p3.getFrequency() * 10
	if self.p4 is not None:
	    self.pHistogram.counts[4] = self.p4.getFrequency() * 10

    def pulseOutput(self, sender, out, clock):

	# return

	# Reward based on what part of the frequency changing cycle we are in.
	# Can the network learn this decode task? (no)

	if out <= 1:
	    if out == int(self.freqTableIndex / 4.0) :
		# print "REWARD out = ", out, "index", self.freqTableIndex
		self.reward(+1, doDebug=self.doDebug0Once)
	    # else:
		# print "PUNISH out = ", out, "index", self.freqTableIndex
		# self.reward(-1, doDebug=self.doDebug1Once)

	self.doDebug0Once = False
	self.doDebug1Once = False

	return

    	if out == 1:
	    self.reward(-1+random.random()*0.01, doDebug=self.doDebug0Once)
	    self.doDebug0Once = False
    	if out == 5:
	    self.reward(1+random.random()*0.01, doDebug=self.doDebug1Once)
	    self.doDebug1Once = False

    def displayTrigger(self, clock):
	self.doDebug0Once = True
	self.doDebug1Once = True

	if clock < 1:
	    # reset counts even if we don't display, to keep first display
	    # from having huge counts and messing up auto-scaling of histograms
	    self.net.resetCounts()
	    return

	if True:
	    # Slave old counts (before we reduce wLearningSpeed)
	    if clock / 3600 >= self.nextCountResetHour:
		self.oldCounts.append((self.counts, self.net.wLearningSpeed,
		    self.net.predictLRightCount[:], self.net.predictLWrongCount[:],
		    self.net.predictHRightCount[:], self.net.predictHWrongCount[:]
		    ))
		if len(self.oldCounts) > 10: # keep the last 5
		    del self.oldCounts[0]
		self.counts = [0]*self.net.rows
		self.nextCountResetHour += self.nextCountResetHourInc


	if self.doWReduce:
	    # Reduce wLarningSpeed
	    if clock / 3600 >= self.nextWReduceHour:
	    	self.net.wLearningSpeed *= self.wReduceFactor
	    	if self.net.wLearningSpeed < self.wReduceMinW:
		    self.net.wLearningSpeed = self.wReduceMinW
	    	# self.net.wLearningSpeed = 0.0 # turn wLearning off to see what happens!
		self.nextWReduceHour += self.nextWReduceHourInc

	self.displayHeader()

	if self.p0 is not None:
	    print "p0 freq: %4.1f " % self.p0.getFrequency(),
	    self.pHistogram.printBar(0)
	    print

	print "p1 freq: %4.1f " % self.p1.getFrequency(),
	self.pHistogram.printBar(1)
	print

	print "p2 freq: %4.1f " % self.p2.getFrequency(),
	self.pHistogram.printBar(2)
	print

	if self.p3 is not None:
	    print "p3 freq: %4.1f " % self.p3.getFrequency(),
	    self.pHistogram.printBar(3)
	    print

	if self.p4 is not None:
	    print "p4 freq: %4.1f " % self.p4.getFrequency(),
	    self.pHistogram.printBar(4)
	    print

	self.net.show(now=clock, doB=False, doQ=False)

	if True:
	    if self.p0 is not None:
		self.net.showNode(self.p0.row, 0)
	    self.net.showNode(self.p1.row, 0)
	    self.net.showNode(self.p2.row, 0)
	    if self.p3 is not None:
		self.net.showNode(self.p3.row, 0)
	    if self.p4 is not None:
		self.net.showNode(self.p4.row, 0)

	if False:
	    # print all w values
	    for c in range(self.net.cols):
		for r in range(self.net.rows):
		    if self.net.nodes[r][c].totalPCount > 0 and len(self.net.nodes[r][c].links) > 0:
			print "[%2d,%2d]" % (r, c),
			for i in range(len(self.net.nodes[r][c].links)):
			    print "%7.5f" % self.net.nodes[r][c].links[i].w,
			print

	if True:
	    # Calculate total energy for each column
	    print "Total Energy By Column:",
	    eSum = 0.0
	    for c in range(self.net.cols):
		e = 0.0
	    	for r in range(self.net.rows):
		    e += self.net.nodes[r][c].atEnergy.getAvg()
		eSum += e
		print "%8.4f" % e,
	    print "Total: %8.4f" % eSum

	if False:
	    for r in range(len(self.counts)):
	    	self.counts[r] += self.net.rowHistogram.counts[r]

	    print
	    #print "row counts are:"
	    print "Percent right by column:"

	    self.displayCounts(self.counts, self.net.wLearningSpeed,
		self.net.predictLRightCount, self.net.predictLWrongCount,
		self.net.predictHRightCount, self.net.predictHWrongCount
		)

	    for o in range(len(self.oldCounts)):
		(cnts, w, lRight, lWrong, hRight, hWrong) = self.oldCounts[len(self.oldCounts)-o-1]
		self.displayCounts(cnts, w, lRight, lWrong, hRight, hWrong)
	    	
	self.net.resetCounts()

	if clock % 3600 == 0.0:
	    if self.plotter0.isClosed():
		self.plotter0 = PlotCol(self, self.net, 0, gap=self.plotGap)

	    if self.net.cols > 2:
		if self.plotter1.isClosed():
		    self.plotter1 = PlotCol(self, self.net, 1, gap=self.plotGap)

	    if self.net.cols > 3:
		if self.plotter2.isClosed():
		    self.plotter2 = PlotCol(self, self.net, 2, gap=self.plotGap)

	    if self.plotter3.isClosed():
		self.plotter3 = PlotCol(self, self.net, self.net.cols-1, gap=self.plotGap)

    def displayCounts(self, cnts, w, lRight, lWrong, hRight, hWrong):
	for i in range(len(lRight)): # assume all right/wrong is same size array
	    if lRight[i] + lWrong[i] > 0:
		s = 100.0 / (lRight[i] + lWrong[i])
	    else:
		s = 0.0
	    print "%5.2f%%" % (lRight[i] * s),
	    if hRight[i] + hWrong[i] > 0:
		s = 100.0 / (hRight[i] + hWrong[i])
	    else:
		s = 0.0
	    print "%5.2f%%" % (hRight[i] * s),

	s = sum(cnts)
	m = float(s) / len(cnts)
	var = 0.0
	if False:
	    for r in range(len(cnts)):
		c = cnts[r] 
		if c > 0:
		    print "%10d %4.1f%%"  % (c, c*100.0/s),
		var += (c - m) ** 2.0
	    var /= s
	    print "[sd:%.3f w:%.1e]" % (math.sqrt(var), w),
	print

class TwoNodeBigNet(Simulator):
    # two nodes with one shared node overlaping
    # copied form TwoNodeOverlapTest()
    # set up a big net and watch how the data flows though
    # by looking only at O values.
    def __init__(self):

    	Simulator.__init__(self)

	self.net = Network(11, 10, "Two Node Big Net",
	    halfLife=0.01,
	    # qValue=0.0,
	    qLearningSpeed=.000001,
	    bLearningSpeed=.00001,
	    sdRatio=1000.0,
	    wLearningSpeed=.0001,
	    wireFanOut=5,
	    wireBinary=False,
	    forceExploration=0.01
	)

	self.net.rowHistogram.setFixedScale(200)
	p1Row = int(self.net.rows / 2) - 1
	# self.p0 = PulseGenerator(self, "p0", self.net, p1Row-2, frequency=1.0, resultMethod=self.pulseOutput)
	self.p1 = PulseGenerator(self, "p1", self.net, p1Row, frequency=1.0, resultMethod=self.pulseOutput)
	self.p2 = PulseGenerator(self, "p2", self.net, p1Row+2, frequency=1.0, resultMethod=self.pulseOutput)
	self.p3 = PulseGenerator(self, "p3", self.net, p1Row+4, frequency=1.0, resultMethod=self.pulseOutput)
	Process(self, "freq", gap=300.0, triggerMethod=self.changeFreq)
	Process(self, "disp", triggerMethod=self.displayTrigger, realTime=False, gap=75.0)

	self.pHistogram = Histogram(2, width=50, fixedScale=3)	# to track and display p1 and p2 frequency
	self.updatePHistogram()

	self.doDebug0Once = True
	self.doDebug1Once = True

	self.freqTable = []
	self.freqTable.append((1.0, 1.0))
	self.freqTable.append((1.0, 2.0))
	self.freqTable.append((1.0, 3.0))
	self.freqTable.append((2.0, 3.0))
	self.freqTable.append((3.0, 3.0))
	self.freqTable.append((3.0, 2.0))
	self.freqTable.append((3.0, 1.0))
	self.freqTable.append((2.0, 1.0))
	self.freqTable.append((1.0, 1.0))
	self.freqTable.append((2.0, 2.0))
	self.freqTable.append((3.0, 3.0))
	self.freqTable.append((2.0, 2.0))

	self.freqTable = []
	self.freqTable.append((1.0, 1.0)) # Binary count 0 to 3
	self.freqTable.append((1.0, 2.0))
	self.freqTable.append((2.0, 1.0))
	self.freqTable.append((2.0, 2.0))
	self.freqTotal = 5.0			# A number greater than the sum of the max frequencies
	self.freqTableIndex = 0


	self.counts = [0]*self.net.rows
	self.oldCounts = []		# array of array of saved counts
	self.nextCountResetHour = 50
	self.nextCountResetHourInc = 50

	if False:
	    self.net.nodes[1][0].qValue = 5.49

	self.doWReduce = True

	if self.doWReduce:
	    self.nextWReduceHour = 1 # start reducing wLearning at this hour
	    self.nextWReduceHourInc = 1 # how often after the first
	    self.wReduceFactor = 0.1 # reduction factor
	    self.wReduceFactor = 1.0 # reduction factor	# 1.0 -> don't reduce
	    self.wReduceFactor = 0.9 # reduction factor
	    self.wReduceMinW = 0.000001	# don't reduce below this

	self.plotter = PlotRPS(self, self.net)

    def changeFreq(self, clock):

	self.freqTableIndex = (self.freqTableIndex + 1) % len(self.freqTable)

	f2,f1 = self.freqTable[self.freqTableIndex]

	percentRandom = 0.00 # no random adjust
	percentRandom = 0.01 # 1 percent random frequency adjust factor

	self.p1.setFrequency(f1*(1.0 + (random.random()-0.5)*percentRandom*2.0))
	self.p2.setFrequency(f2*(1.0 + (random.random()-0.5)*percentRandom*2.0))

	# p0 and p3 balance the pulse rate of p1 and p2 to keep a constant
	# flow of pulses into the net.

	if True:
	    f = self.freqTotal - self.p1.getFrequency() - self.p2.getFrequency()

	    # self.p0.setFrequency(f/2.0)
	    # self.p3.setFrequency(f/2.0)
	    self.p3.setFrequency(f)

	self.updatePHistogram()

	return

	if random.random() > .5:
	    self.p1.setFrequency(1.0 + 3.0 - self.p1.getFrequency())
	    if random.random() > .5:
		self.p2.setFrequency(1.0 + 3.0 - self.p2.getFrequency())
	else:
	    self.p2.setFrequency(1.0 + 3.0 - self.p2.getFrequency())

    def updatePHistogram(self):
	self.pHistogram.counts[0] = self.p1.getFrequency() * 10
	self.pHistogram.counts[1] = self.p2.getFrequency() * 10

    def pulseOutput(self, sender, out, clock):

	# Reward based on what part of the frequency changing cycle we are in.
	# Can the network learn this?

	#if random.random() > .10:
	    #return

	if sender == self.p1:
	    if out == 1:
		self.reward(+1)
	    else:
		self.reward(-1)
	else:
	    if out == 1:
		self.reward(-1)
	    else:
		self.reward(+1)

	return

	if out == self.freqTableIndex * 4:
	    self.reward(+1, doDebug=self.doDebug0Once)
	else:
	    self.reward(-1/6, doDebug=self.doDebug1Once)
	self.doDebug0Once = False
	self.doDebug1Once = False

	return

    	if out == 1:
	    self.reward(-1+random.random()*0.01, doDebug=self.doDebug0Once)
	    self.doDebug0Once = False
    	if out == 5:
	    self.reward(1+random.random()*0.01, doDebug=self.doDebug1Once)
	    self.doDebug1Once = False

    def displayTrigger(self, clock):
	self.doDebug0Once = True
	self.doDebug1Once = True

	if clock < 1:
	    # reset counts even if we don't display, to keep first display
	    # from having huge counts and messing up auto-scaling of histograms
	    self.net.resetCounts()
	    return

	if True:
	    # Save old counts (before we reduce wLearningSpeed)
	    if clock / 3600 >= self.nextCountResetHour:
		self.oldCounts.append((self.counts, self.net.wLearningSpeed,
		    self.net.predictLRightCount[:], self.net.predictLWrongCount[:],
		    self.net.predictHRightCount[:], self.net.predictHWrongCount[:]
		    ))
		if len(self.oldCounts) > 10: # keep the last 5
		    del self.oldCounts[0]
		self.counts = [0]*self.net.rows
		self.nextCountResetHour += self.nextCountResetHourInc

	if self.doWReduce:
	    # Reduce wLarningSpeed
	    if clock / 3600 >= self.nextWReduceHour:
	    	self.net.wLearningSpeed *= self.wReduceFactor
	    	if self.net.wLearningSpeed < self.wReduceMinW:
		    self.net.wLearningSpeed = self.wReduceMinW
	    	# self.net.wLearningSpeed = 0.0 # turn wLearning off to see what happens!
		self.nextWReduceHour += self.nextWReduceHourInc

	self.displayHeader()

	print "p1 freq: %4.1f " % self.p1.getFrequency(),
	self.pHistogram.printBar(0)
	print

	print "p2 freq: %4.1f " % self.p2.getFrequency(),
	self.pHistogram.printBar(1)
	print

	self.net.show(now=clock, doB=False, doW=False, doNodeQ=True, doTrack=False)

	print "qMean:         %7.4f %7.4f" % (self.net.qMean.getAvg(), self.net.qMean2.getAvg())

	if True:
	    self.net.showNode(self.p1.row, 0)
	    self.net.showNode(self.p2.row, 0)
	    self.net.showNode(self.p3.row, 0)
	    # self.net.showNode(1, self.net.cols-2)

	if False:
	    self.p1.rowHistogram.printBarGraph()
	    self.p1.resetCounts()
	    self.p2.rowHistogram.printBarGraph()
	    self.p2.resetCounts()
	    self.p3.rowHistogram.printBarGraph()
	    self.p3.resetCounts()

	if False:
	    # print all w values
	    for c in range(self.net.cols):
		for r in range(self.net.rows):
		    if self.net.nodes[r][c].totalPCount > 0 and len(self.net.nodes[r][c].links) > 0:
			print "[%2d,%2d]" % (r, c),
			for i in range(len(self.net.nodes[r][c].links)):
			    print "%7.5f" % self.net.nodes[r][c].links[i].w,
			print


	if False:
	    for r in range(len(self.counts)):
	    	self.counts[r] += self.net.rowHistogram.counts[r]

	    print
	    #print "row counts are:"
	    print "Percent right by column:"

	    self.displayCounts(self.counts, self.net.wLearningSpeed,
		self.net.predictLRightCount, self.net.predictLWrongCount,
		self.net.predictHRightCount, self.net.predictHWrongCount
		)

	    for o in range(len(self.oldCounts)):
		(cnts, w, lRight, lWrong, hRight, hWrong) = self.oldCounts[len(self.oldCounts)-o-1]
		self.displayCounts(cnts, w, lRight, lWrong, hRight, hWrong)
	    	
	self.net.resetCounts()

    def displayCounts(self, cnts, w, lRight, lWrong, hRight, hWrong):
	for i in range(len(lRight)): # assume all right/wrong is same size array
	    if lRight[i] + lWrong[i] > 0:
		s = 100.0 / (lRight[i] + lWrong[i])
	    else:
		s = 0.0
	    print "%5.2f%%" % (lRight[i] * s),
	    if hRight[i] + hWrong[i] > 0:
		s = 100.0 / (hRight[i] + hWrong[i])
	    else:
		s = 0.0
	    print "%5.2f%%" % (hRight[i] * s),

	s = sum(cnts)
	m = float(s) / len(cnts)
	var = 0.0
	if False:
	    for r in range(len(cnts)):
		c = cnts[r] 
		if c > 0:
		    print "%10d %4.1f%%"  % (c, c*100.0/s),
		var += (c - m) ** 2.0
	    var /= s
	    print "[sd:%.3f w:%.1e]" % (math.sqrt(var), w),
	print

class PlotData:
    def __init__(self):
    	# Nothing
	a = 1 

    def pruneData(self, oldList):
	# cut the list size in half by removing
	# every other data point.  Build new list
	# and return it.
	newList = []
	for i in range(0, len(oldList), 2):
	    # Counts 0, 2, 4, 6...
	    newList.append(oldList[i])
	return newList

    def pruneTime(self, oldList):
    	# reduce Time data
	oldSize = len(oldList)
	newSize = int(oldSize/2.0)
	firstTime = oldList[0]
	lastTime = oldList[oldSize-1]
	map = []
	newList = []
	newCnt = 0
	nextTime = firstTime
	for i in range(len(oldList)):
	    if oldList[i] < nextTime:
	    	map.append(0)	# delete it
	    else:
	    	map.append(1)	# keep it
		newList.append(oldList[i])
		newCnt += 1
		nextTime = lastTime - float(lastTime - firstTime) * (newSize - newCnt - 1) / (newSize - 1)

	return newList, map

    def pruneDataWithMap(self, oldList, map):
    	newList = []
	if len(map) != len(oldList):
	    raise Excepetion("Error")
	for i in range(len(oldList)):
	    if map[i]:
	    	newList.append(oldList[i])
	return newList

    def plotTitle(self, label=None):

	n = "%s %dx%d fanOut:%d" % (
		self.net.name,
		self.net.rows,
		self.net.cols,
		self.net.wireFanOut)

	comments = ""

	if label is not None:
	    comments += label + " "

	if len(sys.argv) > 1:
	    for i in range(len(sys.argv)-1):
		if len(comments) > 0:
		    comments += " "
	    	comments += sys.argv[i+1]

	if len(comments) > 0:
	    comments += "\n"

	if self.net.sLevel is not None:
	    p = "Explore: %.0f%% q:%.0e b:%.0e sl:%.0e w:%.0e hl:%.2f\n" % (
		self.net.forceExploration*100.0,
		self.net.qLearningSpeed,
		self.net.bLearningSpeed,
		self.net.sLevel,
		self.net.wLearningSpeed,
		self.net.halfLife)
	else:
	    p = "Explore: %.0f%% q:%.0e b:%.0e sdr:%.0f w:%.0e hl:%.2f\n" % (
		self.net.forceExploration*100.0,
		self.net.qLearningSpeed,
		self.net.bLearningSpeed,
		self.net.sdRatio,
		self.net.wLearningSpeed,
		self.net.halfLife)

	self.ax.set_title(n + "\n" + p + comments)

	if len(comments) > 0:
	    self.ax.set_position([0.15, 0.15, 0.75, 0.65])
	else:
	    self.ax.set_position([0.15, 0.15, 0.75, 0.70])

    def isClosed(self):
	return not plt.fignum_exists(self.figure.number)

class PlotRPS(PlotData):
    def __init__(self, simulator, net, gap=10.0):

	PlotData.__init__(self)

	self.simulator = simulator
	self.net = net
	self.gap = gap

	self.plotRPS = []
	self.plotTime = []

	self.figure, self.ax = plt.subplots()
	self.lines, = self.ax.plot([],[], label = "Rewards Per Second")

	self.plotTitle()

	plt.xlabel("Simulation Hours")
	plt.ylabel("RPS")
	plt.legend(loc='lower right')

	plt.show(block=False)

	self.triggerProcess = Process(self.simulator, "plot", triggerMethod=self.plotTrigger, gap=self.gap)

    def plotTrigger(self, clock):

	if not plt.fignum_exists(self.figure.number):
	    return "remove"

	self.plotRPS.append(self.net.avgRPS2.getAvg())
	self.plotTime.append(clock/3600.0)

	cnt = len(self.plotRPS)

	if cnt > 10000:
	    # Prune data
	    self.plotTime, pruneMap = self.pruneTime(self.plotTime)
	    self.plotRPS = self.pruneDataWithMap(self.plotRPS, pruneMap)

	if cnt % 5 == 0:
	    self.figure.canvas.flush_events()		# process all window events to keep GUI responsive
	    if not plt.fignum_exists(self.figure.number):
		return "remove"

	if cnt < 10 or cnt % 10 == 0:
	    self.lines.set_ydata(self.plotRPS)
	    self.lines.set_xdata(self.plotTime)
	    self.figure.canvas.draw()

	if (cnt < 200 or (cnt < 1000 and cnt % 10 == 0) or
		(cnt % 100 == 0)):

	    yMin = min(self.plotRPS)
	    yMax = max(self.plotRPS)

	    if yMax > yMin:
		yExtra = (yMax-yMin) * .05
		self.ax.set_ylim(yMin-yExtra, yMax+yExtra)

	    self.ax.set_xlim(-clock*0.05/3600.0, clock*1.10/3600.0 + 1.0)

	    self.plotTitle()
d152 2
a153 2
class PlotLinkQ(PlotData):
    def __init__(self, simulator, net, node, gap=10.0):
d155 18
a172 1
	PlotData.__init__(self)
a173 214
	self.simulator = simulator
	self.net = net
	self.node = node
	self.links = node.links		# arrays of Link objects
	self.gap = gap

	self.plotData = []
	self.plotTime = []

	self.lines = []
	self.figure, self.ax = plt.subplots()

	for i in range(len(self.links)):
	    lines, = self.ax.plot([],[], label = ("Link %d" % i))
	    self.lines.append(lines)
	    self.plotData.append([])

	self.plotTitle()

	plt.xlabel("Simulation Hours")
	plt.ylabel("Q")
	plt.legend(loc='lower left')

	plt.show(block=False)

	self.triggerProcess = Process(self.simulator, "plot", triggerMethod=self.plotTrigger, gap=self.gap)

    def plotTitle(self):

	label = "Node[%d][%d]" % (self.node.r, self.node.c)

	PlotData.plotTitle(self, label=label)

    def plotTrigger(self, clock):

	if not plt.fignum_exists(self.figure.number):
	    return "remove"

	for i in range(len(self.links)):
	    self.plotData[i].append(self.links[i].qValue)
	self.plotTime.append(clock/3600.0)

	cnt = len(self.plotData[0])

	if cnt > 10000:
	    # Prune data
	    self.plotTime, pruneMap = self.pruneTime(self.plotTime)
	    for i in range(len(self.links)):
		self.plotData[i] = self.pruneDataWithMap(self.plotData[i], pruneMap)

	if cnt % 5 == 0:
	    self.figure.canvas.flush_events()		# process all window events to keep GUI responsive
	    if not plt.fignum_exists(self.figure.number):
		return "remove"
	    # once very 5 here seems a good trade off between responsifness
	    # and not too much CPU load

	if cnt < 10 or cnt % 10 == 0:
	    for i in range(len(self.links)):
		self.lines[i].set_ydata(self.plotData[i])
		self.lines[i].set_xdata(self.plotTime)
	    self.figure.canvas.draw()

	if (cnt < 200 or (cnt < 1000 and cnt % 10 == 0) or
		(cnt % 100 == 0)):
	    allMin = None
	    allMax = None
	    for i in range(len(self.links)):
		yMin = min(self.plotData[i])
		yMax = max(self.plotData[i])
		if allMin is None:
		    allMin = yMin
		    allMax = yMax
		else:
		    allMin = min(yMin, allMin)
		    allMax = max(yMax, allMax)
	    yExtra = (allMax-allMin) * .05
	    self.ax.set_ylim(allMin-yExtra, allMax+yExtra)
	    self.ax.set_xlim(-clock*0.05/3600.0, clock*1.10/3600.0 + 1.0)
	    self.plotTitle()

class PlotCol(PlotData):
    # Plot the activity trace values of all nodes in a column
    # Along with the the input signal activity Trace values
    # Tryign to study how preception works.
    def __init__(self, simulator, net, col, gap=10.0):

	PlotData.__init__(self)

	self.simulator = simulator
	self.net = net
	self.col = col
	self.gap = gap

	self.plotData = []
	self.plotTime = []

	self.lines = []
	self.figure, self.ax = plt.subplots()

	for i in range(self.net.rows):
	    lines, = self.ax.plot([],[], label = ("Row %d" % i))
	    self.lines.append(lines)
	    self.plotData.append([])

	self.plotTitle()

	plt.xlabel("Simulation Hours")
	plt.ylabel("A")
	plt.legend(loc='lower left')

	plt.show(block=False)

	self.triggerProcess = Process(self.simulator, "plot", triggerMethod=self.plotTrigger, gap=self.gap)

    def plotTitle(self):

	label = "Column %d" % (self.col)

	PlotData.plotTitle(self, label=label)

    def plotTrigger(self, clock):

	if not plt.fignum_exists(self.figure.number):
	    return "remove"

	lines = len(self.plotData)
	for i in range(lines):
	    self.plotData[i].append(self.net.nodes[i][self.col].at.getV(clock)+2.0*(lines-i-1))
	self.plotTime.append(clock/3600.0)

	cnt = len(self.plotData[0])

	if cnt > 10000:
	    # Prune data
	    self.plotTime, pruneMap = self.pruneTime(self.plotTime)
	    for i in range(len(self.plotData)):
		self.plotData[i] = self.pruneDataWithMap(self.plotData[i], pruneMap)

	if cnt % 5 == 0:
	    self.figure.canvas.flush_events()		# process all window events to keep GUI responsive
	    if not plt.fignum_exists(self.figure.number):
		return "remove"
	    # once very 5 here seems a good trade off between responsifness
	    # and not too much CPU load

	if cnt < 10 or cnt % 10 == 0:
	    for i in range(len(self.plotData)):
		self.lines[i].set_ydata(self.plotData[i])
		self.lines[i].set_xdata(self.plotTime)
	    self.figure.canvas.draw()

	if (cnt < 200 or (cnt < 1000 and cnt % 10 == 0) or
		(cnt % 100 == 0)):
	    allMin = None
	    allMax = None
	    for i in range(len(self.plotData)):
		yMin = min(self.plotData[i])
		yMax = max(self.plotData[i])
		if allMin is None:
		    allMin = yMin
		    allMax = yMax
		else:
		    allMin = min(yMin, allMin)
		    allMax = max(yMax, allMax)
	    yExtra = (allMax-allMin) * .05
	    self.ax.set_ylim(allMin-yExtra, allMax+yExtra)

	    minTime = self.plotTime[0]
	    maxTime = self.plotTime[-1]
	    hours = maxTime - minTime

	    self.ax.set_xlim(minTime-hours*0.05, maxTime+hours*0.05+0.01)
	    self.plotTitle()

def aTest():
    p = PlotData()
    t = [1, 1.1, 1.2, 1.5, 1.7, 5, 10, 15, 20, 25, 30, 31, 32, 33, 34, 35, 37, 38, 40, 44, 45, 47, 50, 21, 22, 22.2, 22.3, 49.1, 49.2, 50.098, 51.1]
    d,m = p.pruneTime(t)
    print t
    print d
    print m
    d,m = p.pruneTime(d)
    print "--"
    print d
    print m
    d,m = p.pruneTime(d)
    print "--"
    print d
    print m
    sys.exit()

# aTest()

global doMean
doMean = False # I Dont't trust this anymore


if False and len(sys.argv) > 1:	# disabled for now not using doMean
    if sys.argv[1] == "on":
    	doMean = True
    elif sys.argv[1] == "off":
    	doMean = False
    else:
    	raise Exception("First arg must be 'on' or 'off' for doMean")

# Pick a test to run

HallTest().run(realTime=False, speed=100)
TwoNodeOverlapTest().run(realTime=True, speed=1000)
TwoNodeBigNet().run(realTime=True, speed=1000)
TwoNodeTest().run()
OneNodeTest().run(realTime=False, speed=100)
SimpleTest().run()
d175 1
@
